%hyperhelp title="Compound statements" date="2021-07-11"
*|compound-statements:⚓|*

*|index-0:⚓|*

Compound statements contain (groups of) other statements; they affect or control
the execution of those other statements in some way.  In general, compound
statements span multiple lines, although in simple incarnations a whole compound
statement may be contained in one line.

The |:if:if|, |:while:while| and |:for:for| statements implement traditional control flow
constructs.  |:try:try| specifies exception handlers and/or cleanup code for a group
of statements, while the |:with:with| statement allows the execution of initialization
and finalization code around a block of code.  Function and class definitions
are also syntactically compound statements.

*|index-1:⚓|*

A compound statement consists of one or more ‘clauses.’  A clause consists of a
header and a ‘suite.’  The clause headers of a particular compound statement are
all at the same indentation level. Each clause header begins with a uniquely
identifying keyword and ends with a colon.  A suite is a group of statements
controlled by a clause.  A suite can be one or more semicolon-separated simple
statements on the same line as the header, following the header’s colon, or it
can be one or more indented statements on subsequent lines.  Only the latter
form of a suite can contain nested compound statements; the following is
illegal, mostly because it wouldn’t be clear to which |:if:if| clause a following
|:else:else| clause would belong:

```rst
if test1: if test2: print(x)
```

Also note that the semicolon binds tighter than the colon in this context, so
that in the following example, either all or none of the |:library/functions.txt/print:print()| calls are
executed:

```rst
if x < y < z: print(x); print(y); print(z)
```

Summarizing:

   compound_stmt ::= if_stmt
                     | while_stmt
                     | for_stmt
                     | try_stmt
                     | with_stmt
                     | funcdef
                     | classdef
                     | async_with_stmt
                     | async_for_stmt
                     | async_funcdef
   suite         ::= stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT
   statement     ::= stmt_list NEWLINE | compound_stmt
   stmt_list     ::= simple_stmt (";" simple_stmt)* [";"]

*|index-2:⚓|*

Note that statements always end in a "NEWLINE" possibly followed by a "DEDENT".
Also note that optional continuation clauses always begin with a keyword that
cannot start a statement, thus there are no ambiguities (the ‘dangling |:else:else|’
problem is solved in Python by requiring nested |:if:if| statements to be indented).

The formatting of the grammar rules in the following sections places each clause
on a separate line for clarity.

*|if:⚓|* *|elif:⚓|* # the-if-statement:The "if" statement*|index-3:⚓|*

The |:if:if| statement is used for conditional execution:

   if_stmt ::= "if" assignment_expression ":" suite
               ("elif" assignment_expression ":" suite)*
               ["else" ":" suite]

It selects exactly one of the suites by evaluating the expressions one by one
until one is found to be true (see section |:reference/expressions.txt/booleans:Boolean operations| for the
definition of true and false); then that suite is executed (and no other part of
the |:if:if| statement is executed or evaluated).  If all expressions are false, the
suite of the |:else:else| clause, if present, is executed.

*|while:⚓|* # the-while-statement:The "while" statement*|index-4:⚓|*

The |:while:while| statement is used for repeated execution as long as an expression is
true:

   while_stmt ::= "while" assignment_expression ":" suite
                  ["else" ":" suite]

This repeatedly tests the expression and, if it is true, executes the first
suite; if the expression is false (which may be the first time it is tested) the
suite of the "else" clause, if present, is executed and the loop terminates.

*|index-5:⚓|*

A |:reference/simple_stmts.txt/break:break| statement executed in the first suite terminates the loop without
executing the "else" clause’s suite.  A |:reference/simple_stmts.txt/continue:continue| statement executed in the
first suite skips the rest of the suite and goes back to testing the expression.

*|for:⚓|* # the-for-statement:The "for" statement*|index-6:⚓|*

The |:for:for| statement is used to iterate over the elements of a sequence (such as
a string, tuple or list) or other iterable object:

   for_stmt ::= "for" target_list "in" expression_list ":" suite
                ["else" ":" suite]

The expression list is evaluated once; it should yield an iterable object.  An
iterator is created for the result of the "expression_list".  The suite is then
executed once for each item provided by the iterator, in the order returned by
the iterator.  Each item in turn is assigned to the target list using the
standard rules for assignments (see |:reference/simple_stmts.txt/assignment:Assignment statements|), and then the suite
is executed.  When the items are exhausted (which is immediately when the
sequence is empty or an iterator raises a |:library/exceptions.txt/StopIteration:StopIteration| exception), the suite
in the "else" clause, if present, is executed, and the loop terminates.

*|index-7:⚓|*

A |:reference/simple_stmts.txt/break:break| statement executed in the first suite terminates the loop without
executing the "else" clause’s suite.  A |:reference/simple_stmts.txt/continue:continue| statement executed in the
first suite skips the rest of the suite and continues with the next item, or
with the "else" clause if there is no next item.

The for-loop makes assignments to the variables in the target list. This
overwrites all previous assignments to those variables including those made in
the suite of the for-loop:

```rst
for i in range(10):
    print(i)
    i = 5             # this will not affect the for-loop
                      # because i will be overwritten with the next
                      # index in the range
```

*|index-8:⚓|*

Names in the target list are not deleted when the loop is finished, but if the
sequence is empty, they will not have been assigned to at all by the loop.
Hint: the built-in function |:library/stdtypes.txt/range:range()| returns an iterator of integers suitable
to emulate the effect of Pascal’s "for i := a to b do"; e.g., "list(range(3))"
returns the list "[0, 1, 2]".

Note:

  *|index-9:⚓|* There is a subtlety when the sequence is being modified by the
  loop (this can only occur for mutable sequences, e.g. lists).  An internal
  counter is used to keep track of which item is used next, and this is
  incremented on each iteration.  When this counter has reached the length of the
  sequence the loop terminates.  This means that if the suite deletes the current
  (or a previous) item from the sequence, the next item will be skipped (since it
  gets the index of the current item which has already been treated).  Likewise,
  if the suite inserts an item in the sequence before the current item, the
  current item will be treated again the next time through the loop. This can lead
  to nasty bugs that can be avoided by making a temporary copy using a slice of
  the whole sequence, e.g.,

```rst
for x in a[:]:
    if x < 0: a.remove(x)
```

*|try:⚓|* *|except:⚓|* *|finally:⚓|* # the-try-statement:The "try" statement
*|index-10:⚓|*

The |:try:try| statement specifies exception handlers and/or cleanup code for a group
of statements:

   try_stmt  ::= try1_stmt | try2_stmt
   try1_stmt ::= "try" ":" suite
                 ("except" [expression ["as" identifier]] ":" suite)+
                 ["else" ":" suite]
                 ["finally" ":" suite]
   try2_stmt ::= "try" ":" suite
                 "finally" ":" suite

The |:except:except| clause(s) specify one or more exception handlers. When no exception
occurs in the |:try:try| clause, no exception handler is executed. When an exception
occurs in the "try" suite, a search for an exception handler is started.  This
search inspects the except clauses in turn until one is found that matches the
exception.  An expression-less except clause, if present, must be last; it
matches any exception.  For an except clause with an expression, that expression
is evaluated, and the clause matches the exception if the resulting object is
“compatible” with the exception.  An object is compatible with an exception if
it is the class or a base class of the exception object, or a tuple containing
an item that is the class or a base class of the exception object.

If no except clause matches the exception, the search for an exception handler
continues in the surrounding code and on the invocation stack.  [1]

If the evaluation of an expression in the header of an except clause raises an
exception, the original search for a handler is canceled and a search starts for
the new exception in the surrounding code and on the call stack (it is treated
as if the entire |:try:try| statement raised the exception).

*|index-11:⚓|*

When a matching except clause is found, the exception is assigned to the target
specified after the "as" keyword in that except clause, if present, and the
except clause’s suite is executed.  All except clauses must have an executable
block.  When the end of this block is reached, execution continues normally
after the entire try statement.  (This means that if two nested handlers exist
for the same exception, and the exception occurs in the try clause of the inner
handler, the outer handler will not handle the exception.)

When an exception has been assigned using "as target", it is cleared at the end
of the except clause.  This is as if

```rst
except E as N:
    foo
```

was translated to

```rst
except E as N:
    try:
        foo
    finally:
        del N
```

This means the exception must be assigned to a different name to be able to
refer to it after the except clause.  Exceptions are cleared because with the
traceback attached to them, they form a reference cycle with the stack frame,
keeping all locals in that frame alive until the next garbage collection occurs.

*|index-12:⚓|*

Before an except clause’s suite is executed, details about the exception are
stored in the |:library/sys.txt/module-sys:sys| module and can be accessed via |:library/sys.txt/sys.exc_info:sys.exc_info()|.
|:library/sys.txt/sys.exc_info:sys.exc_info()| returns a 3-tuple consisting of the exception class, the
exception instance and a traceback object (see section
|:reference/datamodel.txt/types:The standard type hierarchy|) identifying the point in the program where the
exception occurred.  |:library/sys.txt/sys.exc_info:sys.exc_info()| values are restored to their previous
values (before the call) when returning from a function that handled an
exception.

*|index-13:⚓|*

The optional "else" clause is executed if the control flow leaves the |:try:try|
suite, no exception was raised, and no |:reference/simple_stmts.txt/return:return|, |:reference/simple_stmts.txt/continue:continue|, or |:reference/simple_stmts.txt/break:break|
statement was executed.  Exceptions in the "else" clause are not handled by the
preceding |:except:except| clauses.

*|index-14:⚓|*

If |:finally:finally| is present, it specifies a ‘cleanup’ handler.  The |:try:try| clause is
executed, including any |:except:except| and "else" clauses.  If an exception occurs in
any of the clauses and is not handled, the exception is temporarily saved. The "
finally" clause is executed.  If there is a saved exception it is re-raised at
the end of the "finally" clause.  If the "finally" clause raises another
exception, the saved exception is set as the context of the new exception. If
the "finally" clause executes a |:reference/simple_stmts.txt/return:return|, |:reference/simple_stmts.txt/break:break| or |:reference/simple_stmts.txt/continue:continue| statement, the
saved exception is discarded:

```rst
>>> def f():
...     try:
...         1/0
...     finally:
...         return 42
...
>>> f()
42
```

The exception information is not available to the program during execution of
the |:finally:finally| clause.

*|index-15:⚓|*

When a |:reference/simple_stmts.txt/return:return|, |:reference/simple_stmts.txt/break:break| or |:reference/simple_stmts.txt/continue:continue| statement is executed in the |:try:try| suite
of a "try"…"finally" statement, the |:finally:finally| clause is also executed ‘on the
way out.’

The return value of a function is determined by the last |:reference/simple_stmts.txt/return:return| statement
executed.  Since the |:finally:finally| clause always executes, a "return" statement
executed in the "finally" clause will always be the last one executed:

```rst
>>> def foo():
...     try:
...         return 'try'
...     finally:
...         return 'finally'
...
>>> foo()
'finally'
```

Additional information on exceptions can be found in section |:reference/executionmodel.txt/exceptions:Exceptions|, and
information on using the |:reference/simple_stmts.txt/raise:raise| statement to generate exceptions may be found
in section |:reference/simple_stmts.txt/raise:The raise statement|.

Changed in version 3.8: Prior to Python 3.8, a |:reference/simple_stmts.txt/continue:continue| statement was illegal
in the |:finally:finally| clause due to a problem with the implementation.

*|with:⚓|* *|as:⚓|* # the-with-statement:The "with" statement*|index-16:⚓|*

The |:with:with| statement is used to wrap the execution of a block with methods
defined by a context manager (see section |:reference/datamodel.txt/context-managers:With Statement Context Managers|).
This allows common |:try:try|…|:except:except|…|:finally:finally| usage patterns to be encapsulated
for convenient reuse.

   with_stmt ::= "with" with_item ("," with_item)* ":" suite
   with_item ::= expression ["as" target]

The execution of the |:with:with| statement with one “item” proceeds as follows:

1. The context expression (the expression given in the "with_item") is evaluated to
   obtain a context manager.

2. The context manager’s "__enter__()" is loaded for later use.

3. The context manager’s "__exit__()" is loaded for later use.

4. The context manager’s "__enter__()" method is invoked.

5. If a target was included in the |:with:with| statement, the return value from "
   __enter__()" is assigned to it.

   Note:

     The |:with:with| statement guarantees that if the "__enter__()" method returns without
     an error, then "__exit__()" will always be called. Thus, if an error occurs
     during the assignment to the target list, it will be treated the same as an
     error occurring within the suite would be. See step 6 below.

6. The suite is executed.

7. The context manager’s "__exit__()" method is invoked.  If an exception caused
   the suite to be exited, its type, value, and traceback are passed as arguments
   to "__exit__()". Otherwise, three |:library/constants.txt/None:None| arguments are supplied.

   If the suite was exited due to an exception, and the return value from the "
   __exit__()" method was false, the exception is reraised.  If the return value
   was true, the exception is suppressed, and execution continues with the
   statement following the |:with:with| statement.

   If the suite was exited for any reason other than an exception, the return value
   from "__exit__()" is ignored, and execution proceeds at the normal location for
   the kind of exit that was taken.

The following code:

```rst
with EXPRESSION as TARGET:
    SUITE
```

is semantically equivalent to:

```rst
manager = (EXPRESSION)
enter = type(manager).__enter__
exit = type(manager).__exit__
value = enter(manager)
hit_except = False

try:
    TARGET = value
    SUITE
except:
    hit_except = True
    if not exit(manager, *sys.exc_info()):
        raise
finally:
    if not hit_except:
        exit(manager, None, None, None)
```

With more than one item, the context managers are processed as if multiple
|:with:with| statements were nested:

```rst
with A() as a, B() as b:
    SUITE
```

is semantically equivalent to:

```rst
with A() as a:
    with B() as b:
        SUITE
```

Changed in version 3.1: Support for multiple context expressions.

See also:

  *|index-17:⚓|*
  |:www.python.org/dev/peps/pep-0343:PEP 343| - The “with” statement
     The specification, background, and examples for the Python |:with:with| statement.

*|index-18:⚓|* *|function:⚓|* *|def:⚓|* # function-definitions:Function
definitions*|index-19:⚓|*

A function definition defines a user-defined function object (see section
|:reference/datamodel.txt/types:The standard type hierarchy|):

   funcdef                   ::= [decorators] "def" funcname "(" [parameter_list] ")"
               ["->" expression] ":" suite
   decorators                ::= decorator+
   decorator                 ::= "@" dotted_name ["(" [argument_list [","]] ")"] NEWLINE
   dotted_name               ::= identifier ("." identifier)*
   parameter_list            ::= defparameter ("," defparameter)* "," "/" ["," [parameter_list_no_posonly]]
                        | parameter_list_no_posonly
   parameter_list_no_posonly ::= defparameter ("," defparameter)* ["," [parameter_list_starargs]]
                                 | parameter_list_starargs
   parameter_list_starargs   ::= "*" [parameter] ("," defparameter)* ["," ["**" parameter [","]]]
                               | "**" parameter [","]
   parameter                 ::= identifier [":" expression]
   defparameter              ::= parameter ["=" expression]
   funcname                  ::= identifier

A function definition is an executable statement.  Its execution binds the
function name in the current local namespace to a function object (a wrapper
around the executable code for the function).  This function object contains a
reference to the current global namespace as the global namespace to be used
when the function is called.

The function definition does not execute the function body; this gets executed
only when the function is called. [2]

*|index-20:⚓|*

A function definition may be wrapped by one or more |:glossary.txt/term-decorator:decorator| expressions.
Decorator expressions are evaluated when the function is defined, in the scope
that contains the function definition.  The result must be a callable, which is
invoked with the function object as the only argument. The returned value is
bound to the function name instead of the function object.  Multiple decorators
are applied in nested fashion. For example, the following code

```rst
@f1(arg)
@f2
def func(): pass
```

is roughly equivalent to

```rst
def func(): pass
func = f1(arg)(f2(func))
```

except that the original function is not temporarily bound to the name "func".

*|index-21:⚓|*

When one or more |:glossary.txt/term-parameter:parameters| have the form *parameter* "=" *expression*, the
function is said to have “default parameter values.”  For a parameter with a
default value, the corresponding |:glossary.txt/term-argument:argument| may be omitted from a call, in which
case the parameter’s default value is substituted.  If a parameter has a default
value, all following parameters up until the “"*"” must also have a default
value — this is a syntactic restriction that is not expressed by the grammar.

*Default parameter values are evaluated from left to right when the function
definition is executed.* This means that the expression is evaluated once, when
the function is defined, and that the same “pre-computed” value is used for each
call.  This is especially important to understand when a default parameter is a
mutable object, such as a list or a dictionary: if the function modifies the
object (e.g. by appending an item to a list), the default value is in effect
modified.  This is generally not what was intended.  A way around this is to use
"None" as the default, and explicitly test for it in the body of the function,
e.g.:

```rst
def whats_on_the_telly(penguin=None):
    if penguin is None:
        penguin = []
    penguin.append("property of the zoo")
    return penguin
```

*|index-22:⚓|*

Function call semantics are described in more detail in section |:reference/expressions.txt/calls:Calls|. A
function call always assigns values to all parameters mentioned in the parameter
list, either from position arguments, from keyword arguments, or from default
values.  If the form “"*identifier"” is present, it is initialized to a tuple
receiving any excess positional parameters, defaulting to the empty tuple. If
the form “"**identifier"” is present, it is initialized to a new ordered mapping
receiving any excess keyword arguments, defaulting to a new empty mapping of the
same type.  Parameters after “"*"” or “"*identifier"” are keyword-only
parameters and may only be passed used keyword arguments.

*|index-23:⚓|*

Parameters may have an |:glossary.txt/term-function-annotation:annotation| of the form “": expression"” following the
parameter name.  Any parameter may have an annotation, even those of the form "
*identifier" or "**identifier".  Functions may have “return” annotation of the
form “"-> expression"” after the parameter list.  These annotations can be any
valid Python expression.  The presence of annotations does not change the
semantics of a function.  The annotation values are available as values of a
dictionary keyed by the parameters’ names in the "__annotations__" attribute of
the function object.  If the "annotations" import from |:library/__future__.txt/module-__future__:__future__| is used,
annotations are preserved as strings at runtime which enables postponed
evaluation.  Otherwise, they are evaluated when the function definition is
executed.  In this case annotations may be evaluated in a different order than
they appear in the source code.

*|index-24:⚓|*

It is also possible to create anonymous functions (functions not bound to a
name), for immediate use in expressions.  This uses lambda expressions,
described in section |:reference/expressions.txt/lambda:Lambdas|.  Note that the lambda expression is merely a
shorthand for a simplified function definition; a function defined in a “|:def:def|”
statement can be passed around or assigned to another name just like a function
defined by a lambda expression.  The “"def"” form is actually more powerful
since it allows the execution of multiple statements and annotations.

*Programmer’s note:* Functions are first-class objects.  A “"def"” statement
executed inside a function definition defines a local function that can be
returned or passed around.  Free variables used in the nested function can
access the local variables of the function containing the def.  See section
|:reference/executionmodel.txt/naming:Naming and binding| for details.

See also:

  *|index-25:⚓|*
  |:www.python.org/dev/peps/pep-3107:PEP 3107| - Function Annotations
     The original specification for function annotations.

  *|index-26:⚓|*
  |:www.python.org/dev/peps/pep-0484:PEP 484| - Type Hints
     Definition of a standard meaning for annotations: type hints.

  *|index-27:⚓|*
  |:www.python.org/dev/peps/pep-0526:PEP 526| - Syntax for Variable Annotations
     Ability to type hint variable declarations, including class variables and
     instance variables

  *|index-28:⚓|*
  |:www.python.org/dev/peps/pep-0563:PEP 563| - Postponed Evaluation of Annotations
     Support for forward references within annotations by preserving annotations in a
     string form at runtime instead of eager evaluation.

*|class:⚓|* # class-definitions:Class definitions*|index-29:⚓|*

A class definition defines a class object (see section
|:reference/datamodel.txt/types:The standard type hierarchy|):

   classdef    ::= [decorators] "class" classname [inheritance] ":" suite
   inheritance ::= "(" [argument_list] ")"
   classname   ::= identifier

A class definition is an executable statement.  The inheritance list usually
gives a list of base classes (see |:reference/datamodel.txt/metaclasses:Metaclasses| for more advanced uses), so each
item in the list should evaluate to a class object which allows subclassing.
Classes without an inheritance list inherit, by default, from the base class
|:library/functions.txt/object:object|; hence,

```rst
class Foo:
    pass
```

is equivalent to

```rst
class Foo(object):
    pass
```

The class’s suite is then executed in a new execution frame (see
|:reference/executionmodel.txt/naming:Naming and binding|), using a newly created local namespace and the original
global namespace. (Usually, the suite contains mostly function definitions.)
When the class’s suite finishes execution, its execution frame is discarded but
its local namespace is saved. [3] A class object is then created using the
inheritance list for the base classes and the saved local namespace for the
attribute dictionary.  The class name is bound to this class object in the
original local namespace.

The order in which attributes are defined in the class body is preserved in the
new class’s "__dict__".  Note that this is reliable only right after the class
is created and only for classes that were defined using the definition syntax.

Class creation can be customized heavily using |:reference/datamodel.txt/metaclasses:metaclasses|.

*|index-30:⚓|*

Classes can also be decorated: just like when decorating functions,

```rst
@f1(arg)
@f2
class Foo: pass
```

is roughly equivalent to

```rst
class Foo: pass
Foo = f1(arg)(f2(Foo))
```

The evaluation rules for the decorator expressions are the same as for function
decorators.  The result is then bound to the class name.

*Programmer’s note:* Variables defined in the class definition are class
attributes; they are shared by instances.  Instance attributes can be set in a
method with "self.name = value".  Both class and instance attributes are
accessible through the notation “"self.name"”, and an instance attribute hides a
class attribute with the same name when accessed in this way.  Class attributes
can be used as defaults for instance attributes, but using mutable values there
can lead to unexpected results.  |:reference/datamodel.txt/descriptors:Descriptors| can be used to create instance
variables with different implementation details.

See also:

  *|index-31:⚓|*
  |:www.python.org/dev/peps/pep-3115:PEP 3115| - Metaclasses in Python 3000
     The proposal that changed the declaration of metaclasses to the current syntax,
     and the semantics for how classes with metaclasses are constructed.

  *|index-32:⚓|*
  |:www.python.org/dev/peps/pep-3129:PEP 3129| - Class Decorators
     The proposal that added class decorators.  Function and method decorators were
     introduced in *|index-33:⚓|* |:www.python.org/dev/peps/pep-0318:PEP 318|.

*|async:⚓|* # coroutines:Coroutines

New in version 3.5.

*|index-34:⚓|* ## coroutine-function-definition:Coroutine function definition

   async_funcdef ::= [decorators] "async" "def" funcname "(" [parameter_list] ")"
                     ["->" expression] ":" suite

*|index-35:⚓|*

Execution of Python coroutines can be suspended and resumed at many points (see
|:glossary.txt/term-coroutine:coroutine|).  Inside the body of a coroutine function, "await" and "async"
identifiers become reserved keywords; |:reference/expressions.txt/await:await| expressions, |:async-for:async for| and
|:async-with:async with| can only be used in coroutine function bodies.

Functions defined with "async def" syntax are always coroutine functions, even
if they do not contain "await" or "async" keywords.

It is a |:library/exceptions.txt/SyntaxError:SyntaxError| to use a "yield from" expression inside the body of a
coroutine function.

An example of a coroutine function:

```rst
async def func(param1, param2):
    do_stuff()
    await some_coroutine()
```

*|index-36:⚓|* *|async-for:⚓|* ## the-async-for-statement:The "async for"
statement

   async_for_stmt ::= "async" for_stmt

An |:glossary.txt/term-asynchronous-iterable:asynchronous iterable| is able to call asynchronous code in its *iter*
implementation, and |:glossary.txt/term-asynchronous-iterator:asynchronous iterator| can call asynchronous code in its *
next* method.

The "async for" statement allows convenient iteration over asynchronous
iterators.

The following code:

```rst
async for TARGET in ITER:
    SUITE
else:
    SUITE2
```

Is semantically equivalent to:

```rst
iter = (ITER)
iter = type(iter).__aiter__(iter)
running = True

while running:
    try:
        TARGET = await type(iter).__anext__(iter)
    except StopAsyncIteration:
        running = False
    else:
        SUITE
else:
    SUITE2
```

See also "__aiter__()" and "__anext__()" for details.

It is a |:library/exceptions.txt/SyntaxError:SyntaxError| to use an "async for" statement outside the body of a
coroutine function.

*|index-37:⚓|* *|async-with:⚓|* ## the-async-with-statement:The "async with"
statement

   async_with_stmt ::= "async" with_stmt

An |:glossary.txt/term-asynchronous-context-manager:asynchronous context manager| is a |:glossary.txt/term-context-manager:context manager| that is able to suspend
execution in its *enter* and *exit* methods.

The following code:

```rst
async with EXPRESSION as TARGET:
    SUITE
```

is semantically equivalent to:

```rst
manager = (EXPRESSION)
aexit = type(manager).__aexit__
aenter = type(manager).__aenter__
value = await aenter(manager)
hit_except = False

try:
    TARGET = value
    SUITE
except:
    hit_except = True
    if not await aexit(manager, *sys.exc_info()):
        raise
finally:
    if not hit_except:
        await aexit(manager, None, None, None)
```

See also "__aenter__()" and "__aexit__()" for details.

It is a |:library/exceptions.txt/SyntaxError:SyntaxError| to use an "async with" statement outside the body of a
coroutine function.

See also:

  *|index-38:⚓|*
  |:www.python.org/dev/peps/pep-0492:PEP 492| - Coroutines with async and await syntax
     The proposal that made coroutines a proper standalone concept in Python, and
     added supporting syntax.

-[ Footnotes ]-

[1] The exception is propagated to the invocation stack unless there is a |:finally:finally|
    clause which happens to raise another exception. That new exception causes the
    old one to be lost.

[2] A string literal appearing as the first statement in the function body is
    transformed into the function’s "__doc__" attribute and therefore the function’s
    |:glossary.txt/term-docstring:docstring|.

[3] A string literal appearing as the first statement in the class body is
    transformed into the namespace’s "__doc__" item and therefore the class’s
    |:glossary.txt/term-docstring:docstring|.



