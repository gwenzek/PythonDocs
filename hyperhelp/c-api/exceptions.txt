%hyperhelp title="Exception Handling" date="2021-07-11"
*|exception-handling:⚓|*

The functions described in this chapter will let you handle and raise Python
exceptions.  It is important to understand some of the basics of Python
exception handling.  It works somewhat like the POSIX "errno" variable: there is
a global indicator (per thread) of the last error that occurred.  Most C API
functions don’t clear this on success, but will set it to indicate the cause of
the error on failure.  Most C API functions also return an error indicator,
usually "NULL" if they are supposed to return a pointer, or "-1" if they return
an integer (exception: the *PyArg_** functions return "1" for success and "0"
for failure).

Concretely, the error indicator consists of three object pointers: the
exception’s type, the exception’s value, and the traceback object.  Any of those
pointers can be "NULL" if non-set (although some combinations are forbidden, for
example you can’t have a non-"NULL" traceback if the exception type is "NULL").

When a function must fail because some function it called failed, it generally
doesn’t set the error indicator; the function it called already set it.  It is
responsible for either handling the error and clearing the exception or
returning after cleaning up any resources it holds (such as object references or
memory allocations); it should *not* continue normally if it is not prepared to
handle the error.  If returning due to an error, it is important to indicate to
the caller that an error has been set.  If the error is not handled or carefully
propagated, additional calls into the Python/C API may not behave as intended
and may fail in mysterious ways.

Note:

  The error indicator is *not* the result of |:library/sys.txt/sys.exc_info:sys.exc_info()|. The former
  corresponds to an exception that is not yet caught (and is therefore still
  propagating), while the latter returns an exception after it is caught (and has
  therefore stopped propagating).

# printing-and-clearing:Printing and clearing

*c.PyErr_Clear:void PyErr_Clear()
*

   Clear the error indicator.  If the error indicator is not set, there is no
   effect.

*c.PyErr_PrintEx:void PyErr_PrintEx(int set_sys_last_vars)
*

   Print a standard traceback to "sys.stderr" and clear the error indicator. *
   Unless* the error is a "SystemExit", in that case no traceback is printed and
   the Python process will exit with the error code specified by the "SystemExit"
   instance.

   Call this function *only* when the error indicator is set.  Otherwise it will
   cause a fatal error!

   If *set_sys_last_vars* is nonzero, the variables |:library/sys.txt/sys.last_type:sys.last_type|,
   |:library/sys.txt/sys.last_value:sys.last_value| and |:library/sys.txt/sys.last_traceback:sys.last_traceback| will be set to the type, value and
   traceback of the printed exception, respectively.

*c.PyErr_Print:void PyErr_Print()
*

   Alias for "PyErr_PrintEx(1)".

*c.PyErr_WriteUnraisable:void PyErr_WriteUnraisable(PyObject *obj)
*

   Call |:library/sys.txt/sys.unraisablehook:sys.unraisablehook()| using the current exception and *obj* argument.

   This utility function prints a warning message to "sys.stderr" when an exception
   has been set but it is impossible for the interpreter to actually raise the
   exception.  It is used, for example, when an exception occurs in an "__del__()"
   method.

   The function is called with a single argument *obj* that identifies the context
   in which the unraisable exception occurred. If possible, the repr of *obj* will
   be printed in the warning message.

   An exception must be set when calling this function.

# raising-exceptions:Raising exceptions

These functions help you set the current thread’s error indicator. For
convenience, some of these functions will always return a "NULL" pointer for use
in a "return" statement.

*c.PyErr_SetString:void PyErr_SetString(PyObject *type, const char *message)
*

   This is the most common way to set the error indicator.  The first argument
   specifies the exception type; it is normally one of the standard exceptions,
   e.g. "PyExc_RuntimeError".  You need not increment its reference count. The
   second argument is an error message; it is decoded from "'utf-8"’.

*c.PyErr_SetObject:void PyErr_SetObject(PyObject *type, PyObject *value)
*

   This function is similar to |:c.PyErr_SetString:PyErr_SetString()| but lets you specify an
   arbitrary Python object for the “value” of the exception.

*c.PyErr_Format:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_Format(PyObject *exception, const char *format, ...)
*
    *Return value: Always NULL.*

   This function sets the error indicator and returns "NULL".  *exception* should
   be a Python exception class.  The *format* and subsequent parameters help format
   the error message; they have the same meaning and values as in
   |:c-api/unicode.txt/c.PyUnicode_FromFormat:PyUnicode_FromFormat()|. *format* is an ASCII-encoded string.

*c.PyErr_FormatV:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
*
    *Return value: Always NULL.*

   Same as |:c.PyErr_Format:PyErr_Format()|, but taking a "va_list" argument rather than a variable
   number of arguments.

   New in version 3.5.

*c.PyErr_SetNone:void PyErr_SetNone(PyObject *type)
*

   This is a shorthand for "PyErr_SetObject(type, Py_None)".

*c.PyErr_BadArgument:int PyErr_BadArgument()
*

   This is a shorthand for "PyErr_SetString(PyExc_TypeError, message)", where *
   message* indicates that a built-in operation was invoked with an illegal
   argument.  It is mostly for internal use.

*c.PyErr_NoMemory:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_NoMemory()
*
    *Return value: Always NULL.*

   This is a shorthand for "PyErr_SetNone(PyExc_MemoryError)"; it returns "NULL" so
   an object allocation function can write "return PyErr_NoMemory();" when it runs
   out of memory.

*c.PyErr_SetFromErrno:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_SetFromErrno(PyObject *type)
*
    *Return value: Always NULL.**|index-0:⚓|*

   This is a convenience function to raise an exception when a C library function
   has returned an error and set the C variable "errno".  It constructs a tuple
   object whose first item is the integer "errno" value and whose second item is
   the corresponding error message (gotten from "strerror()"), and then calls "
   PyErr_SetObject(type, object)".  On Unix, when the "errno" value is "EINTR",
   indicating an interrupted system call, this calls |:c.PyErr_CheckSignals:PyErr_CheckSignals()|, and if
   that set the error indicator, leaves it set to that.  The function always
   returns "NULL", so a wrapper function around a system call can write "return
   PyErr_SetFromErrno(type);" when the system call returns an error.

*c.PyErr_SetFromErrnoWithFilenameObject:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_SetFromErrnoWithFilenameObject(PyObject *type, PyObject *filenameObject)
*
    *Return value: Always NULL.*

   Similar to |:c.PyErr_SetFromErrno:PyErr_SetFromErrno()|, with the additional behavior that if *
   filenameObject* is not "NULL", it is passed to the constructor of *type* as a
   third parameter.  In the case of |:library/exceptions.txt/OSError:OSError| exception, this is used to define the
   "filename" attribute of the exception instance.

*c.PyErr_SetFromErrnoWithFilenameObjects:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_SetFromErrnoWithFilenameObjects(PyObject *type, PyObject *filenameObject, PyObject *filenameObject2)
*
    *Return value: Always NULL.*

   Similar to |:c.PyErr_SetFromErrnoWithFilenameObject:PyErr_SetFromErrnoWithFilenameObject()|, but takes a second filename
   object, for raising errors when a function that takes two filenames fails.

   New in version 3.4.

*c.PyErr_SetFromErrnoWithFilename:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_SetFromErrnoWithFilename(PyObject *type, const char *filename)
*
    *Return value: Always NULL.*

   Similar to |:c.PyErr_SetFromErrnoWithFilenameObject:PyErr_SetFromErrnoWithFilenameObject()|, but the filename is given
   as a C string.  *filename* is decoded from the filesystem encoding (
   |:library/os.txt/os.fsdecode:os.fsdecode()|).

*c.PyErr_SetFromWindowsErr:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_SetFromWindowsErr(int ierr)
*
    *Return value: Always NULL.*

   This is a convenience function to raise |:library/exceptions.txt/WindowsError:WindowsError|. If called with *ierr* of
   *0*, the error code returned by a call to "GetLastError()" is used instead.  It
   calls the Win32 function "FormatMessage()" to retrieve the Windows description
   of error code given by *ierr* or "GetLastError()", then it constructs a tuple
   object whose first item is the *ierr* value and whose second item is the
   corresponding error message (gotten from "FormatMessage()"), and then calls "
   PyErr_SetObject(PyExc_WindowsError, object)". This function always returns "NULL
   ".

   |:library/intro.txt/availability:Availability|: Windows.

*c.PyErr_SetExcFromWindowsErr:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_SetExcFromWindowsErr(PyObject *type, int ierr)
*
    *Return value: Always NULL.*

   Similar to |:c.PyErr_SetFromWindowsErr:PyErr_SetFromWindowsErr()|, with an additional parameter specifying
   the exception type to be raised.

   |:library/intro.txt/availability:Availability|: Windows.

*c.PyErr_SetFromWindowsErrWithFilename:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_SetFromWindowsErrWithFilename(int ierr, const char *filename)
*
    *Return value: Always NULL.*

   Similar to "PyErr_SetFromWindowsErrWithFilenameObject()", but the filename is
   given as a C string.  *filename* is decoded from the filesystem encoding (
   |:library/os.txt/os.fsdecode:os.fsdecode()|).

   |:library/intro.txt/availability:Availability|: Windows.

*c.PyErr_SetExcFromWindowsErrWithFilenameObject:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_SetExcFromWindowsErrWithFilenameObject(PyObject *type, int ierr, PyObject *filename)
*
    *Return value: Always NULL.*

   Similar to "PyErr_SetFromWindowsErrWithFilenameObject()", with an additional
   parameter specifying the exception type to be raised.

   |:library/intro.txt/availability:Availability|: Windows.

*c.PyErr_SetExcFromWindowsErrWithFilenameObjects:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_SetExcFromWindowsErrWithFilenameObjects(PyObject *type, int ierr, PyObject *filename, PyObject *filename2)
*
    *Return value: Always NULL.*

   Similar to |:c.PyErr_SetExcFromWindowsErrWithFilenameObject:PyErr_SetExcFromWindowsErrWithFilenameObject()|, but accepts a
   second filename object.

   |:library/intro.txt/availability:Availability|: Windows.

   New in version 3.4.

*c.PyErr_SetExcFromWindowsErrWithFilename:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_SetExcFromWindowsErrWithFilename(PyObject *type, int ierr, const char *filename)
*
    *Return value: Always NULL.*

   Similar to |:c.PyErr_SetFromWindowsErrWithFilename:PyErr_SetFromWindowsErrWithFilename()|, with an additional parameter
   specifying the exception type to be raised.

   |:library/intro.txt/availability:Availability|: Windows.

*c.PyErr_SetImportError:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_SetImportError(PyObject *msg, PyObject *name, PyObject *path)
*
    *Return value: Always NULL.*

   This is a convenience function to raise |:library/exceptions.txt/ImportError:ImportError|. *msg* will be set as the
   exception’s message string. *name* and *path*, both of which can be "NULL", will
   be set as the |:library/exceptions.txt/ImportError:ImportError|’s respective "name" and "path" attributes.

   New in version 3.3.

*c.PyErr_SyntaxLocationObject:void PyErr_SyntaxLocationObject(PyObject *filename, int lineno, int col_offset)
*

   Set file, line, and offset information for the current exception.  If the
   current exception is not a |:library/exceptions.txt/SyntaxError:SyntaxError|, then it sets additional attributes,
   which make the exception printing subsystem think the exception is a
   |:library/exceptions.txt/SyntaxError:SyntaxError|.

   New in version 3.4.

*c.PyErr_SyntaxLocationEx:void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
*

   Like |:c.PyErr_SyntaxLocationObject:PyErr_SyntaxLocationObject()|, but *filename* is a byte string decoded
   from the filesystem encoding (|:library/os.txt/os.fsdecode:os.fsdecode()|).

   New in version 3.2.

*c.PyErr_SyntaxLocation:void PyErr_SyntaxLocation(const char *filename, int lineno)
*

   Like |:c.PyErr_SyntaxLocationEx:PyErr_SyntaxLocationEx()|, but the col_offset parameter is omitted.

*c.PyErr_BadInternalCall:void PyErr_BadInternalCall()
*

   This is a shorthand for "PyErr_SetString(PyExc_SystemError, message)", where *
   message* indicates that an internal operation (e.g. a Python/C API function) was
   invoked with an illegal argument.  It is mostly for internal use.

# issuing-warnings:Issuing warnings

Use these functions to issue warnings from C code.  They mirror similar
functions exported by the Python |:library/warnings.txt/module-warnings:warnings| module.  They normally print a
warning message to *sys.stderr*; however, it is also possible that the user has
specified that warnings are to be turned into errors, and in that case they will
raise an exception.  It is also possible that the functions raise an exception
because of a problem with the warning machinery. The return value is "0" if no
exception is raised, or "-1" if an exception is raised.  (It is not possible to
determine whether a warning message is actually printed, nor what the reason is
for the exception; this is intentional.)  If an exception is raised, the caller
should do its normal exception handling (for example, |:c-api/refcounting.txt/c.Py_DECREF:Py_DECREF()| owned
references and return an error value).

*c.PyErr_WarnEx:int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
*

   Issue a warning message.  The *category* argument is a warning category (see
   below) or "NULL"; the *message* argument is a UTF-8 encoded string.  *
   stack_level* is a positive number giving a number of stack frames; the warning
   will be issued from the  currently executing line of code in that stack frame.
   A *stack_level* of 1 is the function calling |:c.PyErr_WarnEx:PyErr_WarnEx()|, 2 is  the
   function above that, and so forth.

   Warning categories must be subclasses of "PyExc_Warning"; "PyExc_Warning" is a
   subclass of "PyExc_Exception"; the default warning category is "
   PyExc_RuntimeWarning". The standard Python warning categories are available as
   global variables whose names are enumerated at |:standardwarningcategories:Standard Warning Categories|.

   For information about warning control, see the documentation for the |:library/warnings.txt/module-warnings:warnings|
   module and the |:using/cmdline.txt/cmdoption-W:-W| option in the command line documentation.  There is no C API
   for warning control.

*c.PyErr_SetImportErrorSubclass:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_SetImportErrorSubclass(PyObject *exception, PyObject *msg, PyObject *name, PyObject *path)
*
    *Return value: Always NULL.*

   Much like |:c.PyErr_SetImportError:PyErr_SetImportError()| but this function allows for specifying a
   subclass of |:library/exceptions.txt/ImportError:ImportError| to raise.

   New in version 3.6.

*c.PyErr_WarnExplicitObject:int PyErr_WarnExplicitObject(PyObject *category, PyObject *message, PyObject *filename, int lineno, PyObject *module, PyObject *registry)
*

   Issue a warning message with explicit control over all warning attributes.  This
   is a straightforward wrapper around the Python function
   |:library/warnings.txt/warnings.warn_explicit:warnings.warn_explicit()|, see there for more information.  The *module* and *
   registry* arguments may be set to "NULL" to get the default effect described
   there.

   New in version 3.4.

*c.PyErr_WarnExplicit:int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
*

   Similar to |:c.PyErr_WarnExplicitObject:PyErr_WarnExplicitObject()| except that *message* and *module* are
   UTF-8 encoded strings, and *filename* is decoded from the filesystem encoding (
   |:library/os.txt/os.fsdecode:os.fsdecode()|).

*c.PyErr_WarnFormat:int PyErr_WarnFormat(PyObject *category, Py_ssize_t stack_level, const char *format, ...)
*

   Function similar to |:c.PyErr_WarnEx:PyErr_WarnEx()|, but use |:c-api/unicode.txt/c.PyUnicode_FromFormat:PyUnicode_FromFormat()| to format
   the warning message.  *format* is an ASCII-encoded string.

   New in version 3.2.

*c.PyErr_ResourceWarning:int PyErr_ResourceWarning(PyObject *source, Py_ssize_t stack_level, const char *format, ...)
*

   Function similar to |:c.PyErr_WarnFormat:PyErr_WarnFormat()|, but *category* is |:library/exceptions.txt/ResourceWarning:ResourceWarning|
   and it passes *source* to "warnings.WarningMessage()".

   New in version 3.6.

# querying-the-error-indicator:Querying the error indicator

*c.PyErr_Occurred:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_Occurred()
*
    *Return value: Borrowed reference.*

   Test whether the error indicator is set.  If set, return the exception *type*
   (the first argument to the last call to one of the *PyErr_Set** functions or to
   |:c.PyErr_Restore:PyErr_Restore()|).  If not set, return "NULL".  You do not own a reference to
   the return value, so you do not need to |:c-api/refcounting.txt/c.Py_DECREF:Py_DECREF()| it.

   Note:

     Do not compare the return value to a specific exception; use
     |:c.PyErr_ExceptionMatches:PyErr_ExceptionMatches()| instead, shown below.  (The comparison could easily
     fail since the exception may be an instance instead of a class, in the case of a
     class exception, or it may be a subclass of the expected exception.)

*c.PyErr_ExceptionMatches:int PyErr_ExceptionMatches(PyObject *exc)
*

   Equivalent to "PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)".  This should
   only be called when an exception is actually set; a memory access violation will
   occur if no exception has been raised.

*c.PyErr_GivenExceptionMatches:int PyErr_GivenExceptionMatches(PyObject *given, PyObject *exc)
*

   Return true if the *given* exception matches the exception type in *exc*.  If *
   exc* is a class object, this also returns true when *given* is an instance of a
   subclass.  If *exc* is a tuple, all exception types in the tuple (and
   recursively in subtuples) are searched for a match.

*c.PyErr_Fetch:void PyErr_Fetch(PyObject **ptype, PyObject **pvalue, PyObject **ptraceback)
*

   Retrieve the error indicator into three variables whose addresses are passed. If
   the error indicator is not set, set all three variables to "NULL".  If it is
   set, it will be cleared and you own a reference to each object retrieved.  The
   value and traceback object may be "NULL" even when the type object is not.

   Note:

     This function is normally only used by code that needs to catch exceptions or by
     code that needs to save and restore the error indicator temporarily, e.g.:

```rst
{
   PyObject *type, *value, *traceback;
   PyErr_Fetch(&type, &value, &traceback);

   /* ... code that might produce other errors ... */

   PyErr_Restore(type, value, traceback);
}
```

*c.PyErr_Restore:void PyErr_Restore(PyObject *type, PyObject *value, PyObject *traceback)
*

   Set  the error indicator from the three objects.  If the error indicator is
   already set, it is cleared first.  If the objects are "NULL", the error
   indicator is cleared.  Do not pass a "NULL" type and non-"NULL" value or
   traceback.  The exception type should be a class.  Do not pass an invalid
   exception type or value. (Violating these rules will cause subtle problems
   later.)  This call takes away a reference to each object: you must own a
   reference to each object before the call and after the call you no longer own
   these references.  (If you don’t understand this, don’t use this function.  I
   warned you.)

   Note:

     This function is normally only used by code that needs to save and restore the
     error indicator temporarily.  Use |:c.PyErr_Fetch:PyErr_Fetch()| to save the current error
     indicator.

*c.PyErr_NormalizeException:void PyErr_NormalizeException(PyObject **exc, PyObject **val, PyObject **tb)
*

   Under certain circumstances, the values returned by |:c.PyErr_Fetch:PyErr_Fetch()| below can be
   “unnormalized”, meaning that "*exc" is a class object but "*val" is not an
   instance of the  same class.  This function can be used to instantiate the class
   in that case.  If the values are already normalized, nothing happens. The
   delayed normalization is implemented to improve performance.

   Note:

     This function *does not* implicitly set the "__traceback__" attribute on the
     exception value. If setting the traceback appropriately is desired, the
     following additional snippet is needed:

```rst
if (tb != NULL) {
  PyException_SetTraceback(val, tb);
}
```

*c.PyErr_GetExcInfo:void PyErr_GetExcInfo(PyObject **ptype, PyObject **pvalue, PyObject **ptraceback)
*

   Retrieve the exception info, as known from "sys.exc_info()".  This refers to an
   exception that was *already caught*, not to an exception that was freshly
   raised.  Returns new references for the three objects, any of which may be "NULL
   ".  Does not modify the exception info state.

   Note:

     This function is not normally used by code that wants to handle exceptions.
     Rather, it can be used when code needs to save and restore the exception state
     temporarily.  Use |:c.PyErr_SetExcInfo:PyErr_SetExcInfo()| to restore or clear the exception state.

   New in version 3.3.

*c.PyErr_SetExcInfo:void PyErr_SetExcInfo(PyObject *type, PyObject *value, PyObject *traceback)
*

   Set the exception info, as known from "sys.exc_info()".  This refers to an
   exception that was *already caught*, not to an exception that was freshly
   raised.  This function steals the references of the arguments. To clear the
   exception state, pass "NULL" for all three arguments. For general rules about
   the three arguments, see |:c.PyErr_Restore:PyErr_Restore()|.

   Note:

     This function is not normally used by code that wants to handle exceptions.
     Rather, it can be used when code needs to save and restore the exception state
     temporarily.  Use |:c.PyErr_GetExcInfo:PyErr_GetExcInfo()| to read the exception state.

   New in version 3.3.

# signal-handling:Signal Handling

*c.PyErr_CheckSignals:int PyErr_CheckSignals()
*
    *|index-1:⚓|*

   This function interacts with Python’s signal handling.  It checks whether a
   signal has been sent to the processes and if so, invokes the corresponding
   signal handler.  If the |:library/signal.txt/module-signal:signal| module is supported, this can invoke a signal
   handler written in Python.  In all cases, the default effect for "SIGINT" is to
   raise the  |:library/exceptions.txt/KeyboardInterrupt:KeyboardInterrupt| exception.  If an exception is raised the error
   indicator is set and the function returns "-1"; otherwise the function returns "
   0".  The error indicator may or may not be cleared if it was previously set.

*c.PyErr_SetInterrupt:void PyErr_SetInterrupt()
*
    *|index-2:⚓|*

   Simulate the effect of a "SIGINT" signal arriving. The next time
   |:c.PyErr_CheckSignals:PyErr_CheckSignals()| is called,  the Python signal handler for "SIGINT" will
   be called.

   If "SIGINT" isn’t handled by Python (it was set to |:library/signal.txt/signal.SIG_DFL:signal.SIG_DFL| or
   |:library/signal.txt/signal.SIG_IGN:signal.SIG_IGN|), this function does nothing.

*c.PySignal_SetWakeupFd:int PySignal_SetWakeupFd(int fd)
*

   This utility function specifies a file descriptor to which the signal number is
   written as a single byte whenever a signal is received. *fd* must be non-
   blocking. It returns the previous such file descriptor.

   The value "-1" disables the feature; this is the initial state. This is
   equivalent to |:library/signal.txt/signal.set_wakeup_fd:signal.set_wakeup_fd()| in Python, but without any error
   checking.  *fd* should be a valid file descriptor.  The function should only be
   called from the main thread.

   Changed in version 3.5: On Windows, the function now also supports socket
   handles.

# exception-classes:Exception Classes

*c.PyErr_NewException:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
*
    *Return value: New reference.*

   This utility function creates and returns a new exception class. The *name*
   argument must be the name of the new exception, a C string of the form "
   module.classname".  The *base* and *dict* arguments are normally "NULL". This
   creates a class object derived from |:library/exceptions.txt/Exception:Exception| (accessible in C as "
   PyExc_Exception").

   The "__module__" attribute of the new class is set to the first part (up to the
   last dot) of the *name* argument, and the class name is set to the last part
   (after the last dot).  The *base* argument can be used to specify alternate base
   classes; it can either be only one class or a tuple of classes. The *dict*
   argument can be used to specify a dictionary of class variables and methods.

*c.PyErr_NewExceptionWithDoc:|:c-api/structures.txt/c.PyObject:PyObject| *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
*
    *Return value: New reference.*

   Same as |:c.PyErr_NewException:PyErr_NewException()|, except that the new exception class can easily
   be given a docstring: If *doc* is non-"NULL", it will be used as the docstring
   for the exception class.

   New in version 3.2.

# exception-objects:Exception Objects

*c.PyException_GetTraceback:|:c-api/structures.txt/c.PyObject:PyObject| *PyException_GetTraceback(PyObject *ex)
*
    *Return value: New reference.*

   Return the traceback associated with the exception as a new reference, as
   accessible from Python through "__traceback__".  If there is no traceback
   associated, this returns "NULL".

*c.PyException_SetTraceback:int PyException_SetTraceback(PyObject *ex, PyObject *tb)
*

   Set the traceback associated with the exception to *tb*.  Use "Py_None" to clear
   it.

*c.PyException_GetContext:|:c-api/structures.txt/c.PyObject:PyObject| *PyException_GetContext(PyObject *ex)
*
    *Return value: New reference.*

   Return the context (another exception instance during whose handling *ex* was
   raised) associated with the exception as a new reference, as accessible from
   Python through "__context__".  If there is no context associated, this returns "
   NULL".

*c.PyException_SetContext:void PyException_SetContext(PyObject *ex, PyObject *ctx)
*

   Set the context associated with the exception to *ctx*.  Use "NULL" to clear it.
   There is no type check to make sure that *ctx* is an exception instance. This
   steals a reference to *ctx*.

*c.PyException_GetCause:|:c-api/structures.txt/c.PyObject:PyObject| *PyException_GetCause(PyObject *ex)
*
    *Return value: New reference.*

   Return the cause (either an exception instance, or |:library/constants.txt/None:None|, set by "raise ...
   from ...") associated with the exception as a new reference, as accessible from
   Python through "__cause__".

*c.PyException_SetCause:void PyException_SetCause(PyObject *ex, PyObject *cause)
*

   Set the cause associated with the exception to *cause*.  Use "NULL" to clear it.
   There is no type check to make sure that *cause* is either an exception instance
   or |:library/constants.txt/None:None|.  This steals a reference to *cause*.

   "__suppress_context__" is implicitly set to "True" by this function.

*|unicodeexceptions:⚓|* # unicode-exception-objects:Unicode Exception Objects

The following functions are used to create and modify Unicode exceptions from C.

*c.PyUnicodeDecodeError_Create:|:c-api/structures.txt/c.PyObject:PyObject| *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
*
    *Return value: New reference.*

   Create a |:library/exceptions.txt/UnicodeDecodeError:UnicodeDecodeError| object with the attributes *encoding*, *object*, *
   length*, *start*, *end* and *reason*. *encoding* and *reason* are UTF-8 encoded
   strings.

*c.PyUnicodeEncodeError_Create:|:c-api/structures.txt/c.PyObject:PyObject| *PyUnicodeEncodeError_Create(const char *encoding, const Py_UNICODE *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
*
    *Return value: New reference.*

   Create a |:library/exceptions.txt/UnicodeEncodeError:UnicodeEncodeError| object with the attributes *encoding*, *object*, *
   length*, *start*, *end* and *reason*. *encoding* and *reason* are UTF-8 encoded
   strings.

   Deprecated since version 3.3: 3.11"Py_UNICODE" is deprecated since Python 3.3.
   Please migrate to "PyObject_CallFunction(PyExc_UnicodeEncodeError, "sOnns", ...)
   ".

*c.PyUnicodeTranslateError_Create:|:c-api/structures.txt/c.PyObject:PyObject| *PyUnicodeTranslateError_Create(const Py_UNICODE *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
*
    *Return value: New reference.*

   Create a |:library/exceptions.txt/UnicodeTranslateError:UnicodeTranslateError| object with the attributes *object*, *length*,
   *start*, *end* and *reason*. *reason* is a UTF-8 encoded string.

   Deprecated since version 3.3: 3.11"Py_UNICODE" is deprecated since Python 3.3.
   Please migrate to "PyObject_CallFunction(PyExc_UnicodeTranslateError, "Onns",
   ...)".

*c.PyUnicodeDecodeError_GetEncoding:|:c-api/structures.txt/c.PyObject:PyObject| *PyUnicodeDecodeError_GetEncoding(PyObject *exc)
*
*c.PyUnicodeEncodeError_GetEncoding:|:c-api/structures.txt/c.PyObject:PyObject| *PyUnicodeEncodeError_GetEncoding(PyObject *exc)
*
    *Return value: New reference.*

   Return the *encoding* attribute of the given exception object.

*c.PyUnicodeDecodeError_GetObject:|:c-api/structures.txt/c.PyObject:PyObject| *PyUnicodeDecodeError_GetObject(PyObject *exc)
*
*c.PyUnicodeEncodeError_GetObject:|:c-api/structures.txt/c.PyObject:PyObject| *PyUnicodeEncodeError_GetObject(PyObject *exc)
*
*c.PyUnicodeTranslateError_GetObject:|:c-api/structures.txt/c.PyObject:PyObject| *PyUnicodeTranslateError_GetObject(PyObject *exc)
*
    *Return value: New reference.*

   Return the *object* attribute of the given exception object.

*c.PyUnicodeDecodeError_GetStart:int PyUnicodeDecodeError_GetStart(PyObject *exc, Py_ssize_t *start)
*
*c.PyUnicodeEncodeError_GetStart:int PyUnicodeEncodeError_GetStart(PyObject *exc, Py_ssize_t *start)
*
*c.PyUnicodeTranslateError_GetStart:int PyUnicodeTranslateError_GetStart(PyObject *exc, Py_ssize_t *start)
*

   Get the *start* attribute of the given exception object and place it into *
   *start*.  *start* must not be "NULL".  Return "0" on success, "-1" on failure.

*c.PyUnicodeDecodeError_SetStart:int PyUnicodeDecodeError_SetStart(PyObject *exc, Py_ssize_t start)
*
*c.PyUnicodeEncodeError_SetStart:int PyUnicodeEncodeError_SetStart(PyObject *exc, Py_ssize_t start)
*
*c.PyUnicodeTranslateError_SetStart:int PyUnicodeTranslateError_SetStart(PyObject *exc, Py_ssize_t start)
*

   Set the *start* attribute of the given exception object to *start*.  Return "0"
   on success, "-1" on failure.

*c.PyUnicodeDecodeError_GetEnd:int PyUnicodeDecodeError_GetEnd(PyObject *exc, Py_ssize_t *end)
*
*c.PyUnicodeEncodeError_GetEnd:int PyUnicodeEncodeError_GetEnd(PyObject *exc, Py_ssize_t *end)
*
*c.PyUnicodeTranslateError_GetEnd:int PyUnicodeTranslateError_GetEnd(PyObject *exc, Py_ssize_t *end)
*

   Get the *end* attribute of the given exception object and place it into **end*.
   *end* must not be "NULL".  Return "0" on success, "-1" on failure.

*c.PyUnicodeDecodeError_SetEnd:int PyUnicodeDecodeError_SetEnd(PyObject *exc, Py_ssize_t end)
*
*c.PyUnicodeEncodeError_SetEnd:int PyUnicodeEncodeError_SetEnd(PyObject *exc, Py_ssize_t end)
*
*c.PyUnicodeTranslateError_SetEnd:int PyUnicodeTranslateError_SetEnd(PyObject *exc, Py_ssize_t end)
*

   Set the *end* attribute of the given exception object to *end*.  Return "0" on
   success, "-1" on failure.

*c.PyUnicodeDecodeError_GetReason:|:c-api/structures.txt/c.PyObject:PyObject| *PyUnicodeDecodeError_GetReason(PyObject *exc)
*
*c.PyUnicodeEncodeError_GetReason:|:c-api/structures.txt/c.PyObject:PyObject| *PyUnicodeEncodeError_GetReason(PyObject *exc)
*
*c.PyUnicodeTranslateError_GetReason:|:c-api/structures.txt/c.PyObject:PyObject| *PyUnicodeTranslateError_GetReason(PyObject *exc)
*
    *Return value: New reference.*

   Return the *reason* attribute of the given exception object.

*c.PyUnicodeDecodeError_SetReason:int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
*
*c.PyUnicodeEncodeError_SetReason:int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
*
*c.PyUnicodeTranslateError_SetReason:int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
*

   Set the *reason* attribute of the given exception object to *reason*.  Return "0
   " on success, "-1" on failure.

# recursion-control:Recursion Control

These two functions provide a way to perform safe recursive calls at the C
level, both in the core and in extension modules.  They are needed if the
recursive code does not necessarily invoke Python code (which tracks its
recursion depth automatically).

*c.Py_EnterRecursiveCall:int Py_EnterRecursiveCall(const char *where)
*

   Marks a point where a recursive C-level call is about to be performed.

   If "USE_STACKCHECK" is defined, this function checks if the OS stack overflowed
   using |:c-api/sys.txt/c.PyOS_CheckStack:PyOS_CheckStack()|.  In this is the case, it sets a |:library/exceptions.txt/MemoryError:MemoryError| and
   returns a nonzero value.

   The function then checks if the recursion limit is reached.  If this is the
   case, a |:library/exceptions.txt/RecursionError:RecursionError| is set and a nonzero value is returned. Otherwise, zero
   is returned.

   *where* should be a string such as "" in instance check"" to be concatenated to
   the |:library/exceptions.txt/RecursionError:RecursionError| message caused by the recursion depth limit.

*c.Py_LeaveRecursiveCall:void Py_LeaveRecursiveCall()
*

   Ends a |:c.Py_EnterRecursiveCall:Py_EnterRecursiveCall()|.  Must be called once for each *successful*
   invocation of |:c.Py_EnterRecursiveCall:Py_EnterRecursiveCall()|.

Properly implementing |:c-api/typeobj.txt/c.PyTypeObject.tp_repr:tp_repr| for container types requires special recursion
handling.  In addition to protecting the stack, |:c-api/typeobj.txt/c.PyTypeObject.tp_repr:tp_repr| also needs to track
objects to prevent cycles.  The following two functions facilitate this
functionality.  Effectively, these are the C equivalent to
|:library/reprlib.txt/reprlib.recursive_repr:reprlib.recursive_repr()|.

*c.Py_ReprEnter:int Py_ReprEnter(PyObject *object)
*

   Called at the beginning of the |:c-api/typeobj.txt/c.PyTypeObject.tp_repr:tp_repr| implementation to detect cycles.

   If the object has already been processed, the function returns a positive
   integer.  In that case the |:c-api/typeobj.txt/c.PyTypeObject.tp_repr:tp_repr| implementation should return a string
   object indicating a cycle.  As examples, |:library/stdtypes.txt/dict:dict| objects return "{...}" and
   |:library/stdtypes.txt/list:list| objects return "[...]".

   The function will return a negative integer if the recursion limit is reached.
   In that case the |:c-api/typeobj.txt/c.PyTypeObject.tp_repr:tp_repr| implementation should typically return "NULL".

   Otherwise, the function returns zero and the |:c-api/typeobj.txt/c.PyTypeObject.tp_repr:tp_repr| implementation can
   continue normally.

*c.Py_ReprLeave:void Py_ReprLeave(PyObject *object)
*

   Ends a |:c.Py_ReprEnter:Py_ReprEnter()|.  Must be called once for each invocation of
   |:c.Py_ReprEnter:Py_ReprEnter()| that returns zero.

*|standardexceptions:⚓|* # standard-exceptions:Standard Exceptions

All standard Python exceptions are available as global variables whose names are
"PyExc_" followed by the Python exception name.  These have the type *|:c-api/structures.txt/c.PyObject:PyObject|
**; they are all class objects.  For completeness, here are all the variables:

*|index-3:⚓|*

+-------------------------------------------+-----------------------------------+------------+
| C Name                                    | Python Name                       | Notes      |
|===========================================|===================================|============|
| "PyExc_BaseException"                     | |:library/exceptions.txt/BaseExc  | (1)        |
|                                           | eption:BaseException|             |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_Exception"                         | |:library/exceptions.txt/Excepti  | (1)        |
|                                           | on:Exception|                     |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ArithmeticError"                   | |:library/exceptions.txt/Arithme  | (1)        |
|                                           | ticError:ArithmeticError|         |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_AssertionError"                    | |:library/exceptions.txt/Asserti  |            |
|                                           | onError:AssertionError|           |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_AttributeError"                    | |:library/exceptions.txt/Attribu  |            |
|                                           | teError:AttributeError|           |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_BlockingIOError"                   | |:library/exceptions.txt/Blockin  |            |
|                                           | gIOError:BlockingIOError|         |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_BrokenPipeError"                   | |:library/exceptions.txt/BrokenP  |            |
|                                           | ipeError:BrokenPipeError|         |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_BufferError"                       | |:library/exceptions.txt/BufferE  |            |
|                                           | rror:BufferError|                 |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ChildProcessError"                 | |:library/exceptions.txt/ChildPr  |            |
|                                           | ocessError:ChildProcessError|     |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ConnectionAbortedError"            | |:library/exceptions.txt/Connect  |            |
|                                           | ionAbortedError:ConnectionAborte  |            |
|                                           | dError|                           |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ConnectionError"                   | |:library/exceptions.txt/Connect  |            |
|                                           | ionError:ConnectionError|         |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ConnectionRefusedError"            | |:library/exceptions.txt/Connect  |            |
|                                           | ionRefusedError:ConnectionRefuse  |            |
|                                           | dError|                           |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ConnectionResetError"              | |:library/exceptions.txt/Connect  |            |
|                                           | ionResetError:ConnectionResetErr  |            |
|                                           | or|                               |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_EOFError"                          | |:library/exceptions.txt/EOFErro  |            |
|                                           | r:EOFError|                       |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_FileExistsError"                   | |:library/exceptions.txt/FileExi  |            |
|                                           | stsError:FileExistsError|         |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_FileNotFoundError"                 | |:library/exceptions.txt/FileNot  |            |
|                                           | FoundError:FileNotFoundError|     |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_FloatingPointError"                | |:library/exceptions.txt/Floatin  |            |
|                                           | gPointError:FloatingPointError|   |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_GeneratorExit"                     | |:library/exceptions.txt/Generat  |            |
|                                           | orExit:GeneratorExit|             |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ImportError"                       | |:library/exceptions.txt/ImportE  |            |
|                                           | rror:ImportError|                 |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_IndentationError"                  | |:library/exceptions.txt/Indenta  |            |
|                                           | tionError:IndentationError|       |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_IndexError"                        | |:library/exceptions.txt/IndexEr  |            |
|                                           | ror:IndexError|                   |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_InterruptedError"                  | |:library/exceptions.txt/Interru  |            |
|                                           | ptedError:InterruptedError|       |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_IsADirectoryError"                 | |:library/exceptions.txt/IsADire  |            |
|                                           | ctoryError:IsADirectoryError|     |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_KeyError"                          | |:library/exceptions.txt/KeyErro  |            |
|                                           | r:KeyError|                       |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_KeyboardInterrupt"                 | |:library/exceptions.txt/Keyboar  |            |
|                                           | dInterrupt:KeyboardInterrupt|     |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_LookupError"                       | |:library/exceptions.txt/LookupE  | (1)        |
|                                           | rror:LookupError|                 |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_MemoryError"                       | |:library/exceptions.txt/MemoryE  |            |
|                                           | rror:MemoryError|                 |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ModuleNotFoundError"               | |:library/exceptions.txt/ModuleN  |            |
|                                           | otFoundError:ModuleNotFoundError| |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_NameError"                         | |:library/exceptions.txt/NameErr  |            |
|                                           | or:NameError|                     |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_NotADirectoryError"                | |:library/exceptions.txt/NotADir  |            |
|                                           | ectoryError:NotADirectoryError|   |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_NotImplementedError"               | |:library/exceptions.txt/NotImpl  |            |
|                                           | ementedError:NotImplementedError| |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_OSError"                           | |:library/exceptions.txt/OSError  | (1)        |
|                                           | :OSError|                         |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_OverflowError"                     | |:library/exceptions.txt/Overflo  |            |
|                                           | wError:OverflowError|             |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_PermissionError"                   | |:library/exceptions.txt/Permiss  |            |
|                                           | ionError:PermissionError|         |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ProcessLookupError"                | |:library/exceptions.txt/Process  |            |
|                                           | LookupError:ProcessLookupError|   |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_RecursionError"                    | |:library/exceptions.txt/Recursi  |            |
|                                           | onError:RecursionError|           |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ReferenceError"                    | |:library/exceptions.txt/Referen  | (2)        |
|                                           | ceError:ReferenceError|           |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_RuntimeError"                      | |:library/exceptions.txt/Runtime  |            |
|                                           | Error:RuntimeError|               |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_StopAsyncIteration"                | |:library/exceptions.txt/StopAsy  |            |
|                                           | ncIteration:StopAsyncIteration|   |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_StopIteration"                     | |:library/exceptions.txt/StopIte  |            |
|                                           | ration:StopIteration|             |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_SyntaxError"                       | |:library/exceptions.txt/SyntaxE  |            |
|                                           | rror:SyntaxError|                 |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_SystemError"                       | |:library/exceptions.txt/SystemE  |            |
|                                           | rror:SystemError|                 |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_SystemExit"                        | |:library/exceptions.txt/SystemE  |            |
|                                           | xit:SystemExit|                   |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_TabError"                          | |:library/exceptions.txt/TabErro  |            |
|                                           | r:TabError|                       |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_TimeoutError"                      | |:library/exceptions.txt/Timeout  |            |
|                                           | Error:TimeoutError|               |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_TypeError"                         | |:library/exceptions.txt/TypeErr  |            |
|                                           | or:TypeError|                     |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_UnboundLocalError"                 | |:library/exceptions.txt/Unbound  |            |
|                                           | LocalError:UnboundLocalError|     |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_UnicodeDecodeError"                | |:library/exceptions.txt/Unicode  |            |
|                                           | DecodeError:UnicodeDecodeError|   |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_UnicodeEncodeError"                | |:library/exceptions.txt/Unicode  |            |
|                                           | EncodeError:UnicodeEncodeError|   |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_UnicodeError"                      | |:library/exceptions.txt/Unicode  |            |
|                                           | Error:UnicodeError|               |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_UnicodeTranslateError"             | |:library/exceptions.txt/Unicode  |            |
|                                           | TranslateError:UnicodeTranslateE  |            |
|                                           | rror|                             |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ValueError"                        | |:library/exceptions.txt/ValueEr  |            |
|                                           | ror:ValueError|                   |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ZeroDivisionError"                 | |:library/exceptions.txt/ZeroDiv  |            |
|                                           | isionError:ZeroDivisionError|     |            |
+-------------------------------------------+-----------------------------------+------------+

New in version 3.3: "PyExc_BlockingIOError", "PyExc_BrokenPipeError", "
PyExc_ChildProcessError", "PyExc_ConnectionError", "PyExc_ConnectionAbortedError
", "PyExc_ConnectionRefusedError", "PyExc_ConnectionResetError", "
PyExc_FileExistsError", "PyExc_FileNotFoundError", "PyExc_InterruptedError", "
PyExc_IsADirectoryError", "PyExc_NotADirectoryError", "PyExc_PermissionError", "
PyExc_ProcessLookupError" and "PyExc_TimeoutError" were introduced following
*|index-4:⚓|* |:www.python.org/dev/peps/pep-3151:PEP 3151|.

New in version 3.5: "PyExc_StopAsyncIteration" and "PyExc_RecursionError".

New in version 3.6: "PyExc_ModuleNotFoundError".

These are compatibility aliases to "PyExc_OSError":

*|index-5:⚓|*

+---------------------------------------+------------+
| C Name                                | Notes      |
|=======================================|============|
| "PyExc_EnvironmentError"              |            |
+---------------------------------------+------------+
| "PyExc_IOError"                       |            |
+---------------------------------------+------------+
| "PyExc_WindowsError"                  | (3)        |
+---------------------------------------+------------+

Changed in version 3.3: These aliases used to be separate exception types.

Notes:

1. This is a base class for other standard exceptions.

2. Only defined on Windows; protect code that uses this by testing that the
   preprocessor macro "MS_WINDOWS" is defined.

*|standardwarningcategories:⚓|* # standard-warning-categories:Standard Warning
Categories

All standard Python warning categories are available as global variables whose
names are "PyExc_" followed by the Python exception name. These have the type *
|:c-api/structures.txt/c.PyObject:PyObject|**; they are all class objects. For completeness, here are all the
variables:

*|index-6:⚓|*

+--------------------------------------------+-----------------------------------+------------+
| C Name                                     | Python Name                       | Notes      |
|============================================|===================================|============|
| "PyExc_Warning"                            | |:library/exceptions.txt/Warning  | (1)        |
|                                            | :Warning|                         |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_BytesWarning"                       | |:library/exceptions.txt/BytesWa  |            |
|                                            | rning:BytesWarning|               |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_DeprecationWarning"                 | |:library/exceptions.txt/Depreca  |            |
|                                            | tionWarning:DeprecationWarning|   |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_FutureWarning"                      | |:library/exceptions.txt/FutureW  |            |
|                                            | arning:FutureWarning|             |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_ImportWarning"                      | |:library/exceptions.txt/ImportW  |            |
|                                            | arning:ImportWarning|             |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_PendingDeprecationWarning"          | |:library/exceptions.txt/Pending  |            |
|                                            | DeprecationWarning:PendingDeprec  |            |
|                                            | ationWarning|                     |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_ResourceWarning"                    | |:library/exceptions.txt/Resourc  |            |
|                                            | eWarning:ResourceWarning|         |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_RuntimeWarning"                     | |:library/exceptions.txt/Runtime  |            |
|                                            | Warning:RuntimeWarning|           |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_SyntaxWarning"                      | |:library/exceptions.txt/SyntaxW  |            |
|                                            | arning:SyntaxWarning|             |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_UnicodeWarning"                     | |:library/exceptions.txt/Unicode  |            |
|                                            | Warning:UnicodeWarning|           |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_UserWarning"                        | |:library/exceptions.txt/UserWar  |            |
|                                            | ning:UserWarning|                 |            |
+--------------------------------------------+-----------------------------------+------------+

New in version 3.2: "PyExc_ResourceWarning".

Notes:

1. This is a base class for other standard warning categories.



