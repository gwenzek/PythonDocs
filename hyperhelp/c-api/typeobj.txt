%hyperhelp title="Type Objects" date="2021-07-11"
*|type-objects:⚓|*

Perhaps one of the most important structures of the Python object system is the
structure that defines a new type: the |:c-api/type.txt/c.PyTypeObject:PyTypeObject| structure.  Type objects
can be handled using any of the *PyObject_** or *PyType_** functions, but do not
offer much that’s interesting to most Python applications. These objects are
fundamental to how objects behave, so they are very important to the interpreter
itself and to any extension module that implements new types.

Type objects are fairly large compared to most of the standard types. The reason
for the size is that each type object stores a large number of values, mostly C
function pointers, each of which implements a small part of the type’s
functionality.  The fields of the type object are examined in detail in this
section.  The fields will be described in the order in which they occur in the
structure.

In addition to the following quick reference, the |:typedef-examples:Examples| section provides
at-a-glance insight into the meaning and use of |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.

# quick-reference:Quick Reference## tp-slots:“tp slots”

+--------------------+--------------------+--------------------+----+----+----+----+
| PyTypeObject Slot  | |:slot-typedefs-   | special            | Info [2]          |
| [1]                | table:Type|        | methods/attrs      |                   |
|                    |                    |                    +----+----+----+----+
|                    |                    |                    | O  | T  | D  | I  |
|                    |                    |                    |    |    |    |    |
|====================|====================|====================|====|====|====|====|
| <R> |:c.PyTypeObj  | const char *       | __name__           | X  | X  |    |    |
| ect.tp_name:tp_na  |                    |                    |    |    |    |    |
| me|                |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | Py_ssize_t         |                    | X  | X  |    | X  |
| tp_basicsize:tp_b  |                    |                    |    |    |    |    |
| asicsize|          |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | Py_ssize_t         |                    |    | X  |    | X  |
| tp_itemsize:tp_it  |                    |                    |    |    |    |    |
| emsize|            |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.destructor:de  |                    | X  | X  |    | X  |
| tp_dealloc:tp_dea  | structor|          |                    |    |    |    |    |
| lloc|              |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | Py_ssize_t         |                    |    |    |    | ?  |
| tp_vectorcall_off  |                    |                    |    |    |    |    |
| set:tp_vectorcall  |                    |                    |    |    |    |    |
| _offset|           |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| (|:c.PyTypeObject  | |:c.getattrfunc:g  | __getattribute__,  |    |    |    | G  |
| .tp_getattr:tp_ge  | etattrfunc|        | __getattr__        |    |    |    |    |
| tattr|)            |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| (|:c.PyTypeObject  | |:c.setattrfunc:s  | __setattr__,       |    |    |    | G  |
| .tp_setattr:tp_se  | etattrfunc|        | __delattr__        |    |    |    |    |
| tattr|)            |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.PyAsyncMethod  | |:sub-slots:sub-   |    |    |    | %  |
| tp_as_async:tp_as  | s:PyAsyncMethods|  | slots|             |    |    |    |    |
| _async|            | *                  |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.reprfunc:repr  | __repr__           | X  | X  |    | X  |
| tp_repr:tp_repr|   | func|              |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.PyNumberMetho  | |:sub-slots:sub-   |    |    |    | %  |
| tp_as_number:tp_a  | ds:PyNumberMethod  | slots|             |    |    |    |    |
| s_number|          | s| *               |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.PySequenceMet  | |:sub-slots:sub-   |    |    |    | %  |
| tp_as_sequence:tp  | hods:PySequenceMe  | slots|             |    |    |    |    |
| _as_sequence|      | thods| *           |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.PyMappingMeth  | |:sub-slots:sub-   |    |    |    | %  |
| tp_as_mapping:tp_  | ods:PyMappingMeth  | slots|             |    |    |    |    |
| as_mapping|        | ods| *             |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.hashfunc:hash  | __hash__           | X  |    |    | G  |
| tp_hash:tp_hash|   | func|              |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.ternaryfunc:t  | __call__           |    | X  |    | X  |
| tp_call:tp_call|   | ernaryfunc|        |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.reprfunc:repr  | __str__            | X  |    |    | X  |
| tp_str:tp_str|     | func|              |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.getattrofunc:  | __getattribute__,  | X  | X  |    | G  |
| tp_getattro:tp_ge  | getattrofunc|      | __getattr__        |    |    |    |    |
| tattro|            |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.setattrofunc:  | __setattr__,       | X  | X  |    | G  |
| tp_setattro:tp_se  | setattrofunc|      | __delattr__        |    |    |    |    |
| tattro|            |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.PyBufferProcs  |                    |    |    |    | %  |
| tp_as_buffer:tp_a  | :PyBufferProcs| *  |                    |    |    |    |    |
| s_buffer|          |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | unsigned long      |                    | X  | X  |    | ?  |
| tp_flags:tp_flags| |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | const char *       | __doc__            | X  | X  |    |    |
| tp_doc:tp_doc|     |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c-api/gcsupport  |                    |    | X  |    | G  |
| tp_traverse:tp_tr  | .txt/c.traversepr  |                    |    |    |    |    |
| averse|            | oc:traverseproc|   |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c-api/gcsupport  |                    |    | X  |    | G  |
| tp_clear:tp_clear| | .txt/c.inquiry:in  |                    |    |    |    |    |
|                    | quiry|             |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.richcmpfunc:r  | __lt__, __le__,    | X  |    |    | G  |
| tp_richcompare:tp  | ichcmpfunc|        | __eq__, __ne__,    |    |    |    |    |
| _richcompare|      |                    | __gt__, __ge__     |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | Py_ssize_t         |                    |    | X  |    | ?  |
| tp_weaklistoffset  |                    |                    |    |    |    |    |
| :tp_weaklistoffse  |                    |                    |    |    |    |    |
| t|                 |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.getiterfunc:g  | __iter__           |    |    |    | X  |
| tp_iter:tp_iter|   | etiterfunc|        |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.iternextfunc:  | __next__           |    |    |    | X  |
| tp_iternext:tp_it  | iternextfunc|      |                    |    |    |    |    |
| ernext|            |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c-api/structure  |                    | X  | X  |    |    |
| tp_methods:tp_met  | s.txt/c.PyMethodD  |                    |    |    |    |    |
| hods|              | ef:PyMethodDef| [] |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c-api/structure  |                    |    | X  |    |    |
| tp_members:tp_mem  | s.txt/c.PyMemberD  |                    |    |    |    |    |
| bers|              | ef:PyMemberDef| [] |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c-api/structure  |                    | X  | X  |    |    |
| tp_getset:tp_gets  | s.txt/c.PyGetSetD  |                    |    |    |    |    |
| et|                | ef:PyGetSetDef| [] |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c-api/type.txt/  | __base__           |    |    | X  |    |
| tp_base:tp_base|   | c.PyTypeObject:Py  |                    |    |    |    |    |
|                    | TypeObject| *      |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c-api/structure  | __dict__           |    |    | ?  |    |
| tp_dict:tp_dict|   | s.txt/c.PyObject:  |                    |    |    |    |    |
|                    | PyObject| *        |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.descrgetfunc:  | __get__            |    |    |    | X  |
| tp_descr_get:tp_d  | descrgetfunc|      |                    |    |    |    |    |
| escr_get|          |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.descrsetfunc:  | __set__,           |    |    |    | X  |
| tp_descr_set:tp_d  | descrsetfunc|      | __delete__         |    |    |    |    |
| escr_set|          |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | Py_ssize_t         |                    |    | X  |    | ?  |
| tp_dictoffset:tp_  |                    |                    |    |    |    |    |
| dictoffset|        |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.initproc:init  | __init__           | X  | X  |    | X  |
| tp_init:tp_init|   | proc|              |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.allocfunc:all  |                    | X  |    | ?  | ?  |
| tp_alloc:tp_alloc| | ocfunc|            |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.newfunc:newfu  | __new__            | X  | X  | ?  | ?  |
| tp_new:tp_new|     | nc|                |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.freefunc:free  |                    | X  | X  | ?  | ?  |
| tp_free:tp_free|   | func|              |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c-api/gcsupport  |                    |    | X  |    | X  |
| tp_is_gc:tp_is_gc| | .txt/c.inquiry:in  |                    |    |    |    |    |
|                    | quiry|             |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| <|:c.PyTypeObject  | |:c-api/structure  | __bases__          |    |    | ~  |    |
| .tp_bases:tp_base  | s.txt/c.PyObject:  |                    |    |    |    |    |
| s|>                | PyObject| *        |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| <|:c.PyTypeObject  | |:c-api/structure  | __mro__            |    |    | ~  |    |
| .tp_mro:tp_mro|>   | s.txt/c.PyObject:  |                    |    |    |    |    |
|                    | PyObject| *        |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| [|:c.PyTypeObject  | |:c-api/structure  |                    |    |    |         |
| .tp_cache:tp_cach  | s.txt/c.PyObject:  |                    |    |    |         |
| e|]                | PyObject| *        |                    |    |    |         |
+--------------------+--------------------+--------------------+----+----+----+----+
| [|:c.PyTypeObject  | |:c-api/structure  | __subclasses__     |    |    |         |
| .tp_subclasses:tp  | s.txt/c.PyObject:  |                    |    |    |         |
| _subclasses|]      | PyObject| *        |                    |    |    |         |
+--------------------+--------------------+--------------------+----+----+----+----+
| [|:c.PyTypeObject  | |:c-api/structure  |                    |    |    |         |
| .tp_weaklist:tp_w  | s.txt/c.PyObject:  |                    |    |    |         |
| eaklist|]          | PyObject| *        |                    |    |    |         |
+--------------------+--------------------+--------------------+----+----+----+----+
| (|:c.PyTypeObject  | |:c.destructor:de  |                    |    |    |    |    |
| .tp_del:tp_del|)   | structor|          |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| [|:c.PyTypeObject  | unsigned int       |                    |    |    |         |
| .tp_version_tag:t  |                    |                    |    |    |         |
| p_version_tag|]    |                    |                    |    |    |         |
+--------------------+--------------------+--------------------+----+----+----+----+
| |:c.PyTypeObject.  | |:c.destructor:de  | __del__            |    |    |    | X  |
| tp_finalize:tp_fi  | structor|          |                    |    |    |    |    |
| nalize|            |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+

If "COUNT_ALLOCS" is defined then the following (internal-only) fields exist as
well:

* |:c.PyTypeObject.tp_allocs:tp_allocs|

* |:c.PyTypeObject.tp_frees:tp_frees|

* |:c.PyTypeObject.tp_maxalloc:tp_maxalloc|

* |:c.PyTypeObject.tp_prev:tp_prev|

* |:c.PyTypeObject.tp_next:tp_next|

[1] A slot name in parentheses indicates it is (effectively) deprecated. Names in
    angle brackets should be treated as read-only. Names in square brackets are for
    internal use only. “<R>” (as a prefix) means the field is required (must be non-
    "NULL").

[2] Columns:

    *“O”*:  set on "PyBaseObject_Type"

    *“T”*:  set on |:c-api/type.txt/c.PyType_Type:PyType_Type|

    *“D”*:  default (if slot is set to "NULL")

```rst
X - PyType_Ready sets this value if it is NULL
~ - PyType_Ready always sets this value (it should be NULL)
? - PyType_Ready may set this value depending on other slots

Also see the inheritance column ("I").
```

    *“I”*:  inheritance

```rst
X - type slot is inherited via PyType_Ready if defined with a NULL value
% - the slots of the sub-struct are inherited individually
G - inherited, but only in combination with other slots; see the slot's description
? - it's complicated; see the slot's description
```

    Note that some slots are effectively inherited through the normal attribute
    lookup chain.

*|sub-slots:⚓|* ## sub-slots:sub-slots

+----------------------------+-------------------+--------------+
| Slot                       | |:slot-typedefs-  | special      |
|                            | table:Type|       | methods      |
|============================|===================|==============|
| |:c.PyAsyncMethods.am_awa  | |:c.unaryfunc:un  | __await__    |
| it:am_await|               | aryfunc|          |              |
+----------------------------+-------------------+--------------+
| |:c.PyAsyncMethods.am_ait  | |:c.unaryfunc:un  | __aiter__    |
| er:am_aiter|               | aryfunc|          |              |
+----------------------------+-------------------+--------------+
| |:c.PyAsyncMethods.am_ane  | |:c.unaryfunc:un  | __anext__    |
| xt:am_anext|               | aryfunc|          |              |
+----------------------------+-------------------+--------------+
|                                                               |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_ad  | |:c.binaryfunc:b  | __add__      |
| d:nb_add|                  | inaryfunc|        | __radd__     |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.binaryfunc:b  | __iadd__     |
| place_add:nb_inplace_add|  | inaryfunc|        |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_su  | |:c.binaryfunc:b  | __sub__      |
| btract:nb_subtract|        | inaryfunc|        | __rsub__     |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.binaryfunc:b  | __sub__      |
| place_subtract:nb_inplace  | inaryfunc|        |              |
| _subtract|                 |                   |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_mu  | |:c.binaryfunc:b  | __mul__      |
| ltiply:nb_multiply|        | inaryfunc|        | __rmul__     |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.binaryfunc:b  | __mul__      |
| place_multiply:nb_inplace  | inaryfunc|        |              |
| _multiply|                 |                   |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_re  | |:c.binaryfunc:b  | __mod__      |
| mainder:nb_remainder|      | inaryfunc|        | __rmod__     |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.binaryfunc:b  | __mod__      |
| place_remainder:nb_inplac  | inaryfunc|        |              |
| e_remainder|               |                   |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_di  | |:c.binaryfunc:b  | __divmod__   |
| vmod:nb_divmod|            | inaryfunc|        | __rdivmod__  |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_po  | |:c.ternaryfunc:  | __pow__      |
| wer:nb_power|              | ternaryfunc|      | __rpow__     |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.ternaryfunc:  | __pow__      |
| place_power:nb_inplace_po  | ternaryfunc|      |              |
| wer|                       |                   |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_ne  | |:c.unaryfunc:un  | __neg__      |
| gative:nb_negative|        | aryfunc|          |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_po  | |:c.unaryfunc:un  | __pos__      |
| sitive:nb_positive|        | aryfunc|          |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_ab  | |:c.unaryfunc:un  | __abs__      |
| solute:nb_absolute|        | aryfunc|          |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_bo  | |:c-api/gcsuppor  | __bool__     |
| ol:nb_bool|                | t.txt/c.inquiry:  |              |
|                            | inquiry|          |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.unaryfunc:un  | __invert__   |
| vert:nb_invert|            | aryfunc|          |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_ls  | |:c.binaryfunc:b  | __lshift__   |
| hift:nb_lshift|            | inaryfunc|        | __rlshift__  |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.binaryfunc:b  | __lshift__   |
| place_lshift:nb_inplace_l  | inaryfunc|        |              |
| shift|                     |                   |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_rs  | |:c.binaryfunc:b  | __rshift__   |
| hift:nb_rshift|            | inaryfunc|        | __rrshift__  |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.binaryfunc:b  | __rshift__   |
| place_rshift:nb_inplace_r  | inaryfunc|        |              |
| shift|                     |                   |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_an  | |:c.binaryfunc:b  | __and__      |
| d:nb_and|                  | inaryfunc|        | __rand__     |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.binaryfunc:b  | __and__      |
| place_and:nb_inplace_and|  | inaryfunc|        |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_xo  | |:c.binaryfunc:b  | __xor__      |
| r:nb_xor|                  | inaryfunc|        | __rxor__     |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.binaryfunc:b  | __xor__      |
| place_xor:nb_inplace_xor|  | inaryfunc|        |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_or  | |:c.binaryfunc:b  | __or__       |
| :nb_or|                    | inaryfunc|        | __ror__      |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.binaryfunc:b  | __or__       |
| place_or:nb_inplace_or|    | inaryfunc|        |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.unaryfunc:un  | __int__      |
| t:nb_int|                  | aryfunc|          |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_re  | void *            |              |
| served:nb_reserved|        |                   |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_fl  | |:c.unaryfunc:un  | __float__    |
| oat:nb_float|              | aryfunc|          |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_fl  | |:c.binaryfunc:b  | __floordiv__ |
| oor_divide:nb_floor_divid  | inaryfunc|        |              |
| e|                         |                   |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.binaryfunc:b  | __floordiv__ |
| place_floor_divide:nb_inp  | inaryfunc|        |              |
| lace_floor_divide|         |                   |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_tr  | |:c.binaryfunc:b  | __truediv__  |
| ue_divide:nb_true_divide|  | inaryfunc|        |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.binaryfunc:b  | __truediv__  |
| place_true_divide:nb_inpl  | inaryfunc|        |              |
| ace_true_divide|           |                   |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.unaryfunc:un  | __index__    |
| dex:nb_index|              | aryfunc|          |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_ma  | |:c.binaryfunc:b  | __matmul__   |
| trix_multiply:nb_matrix_m  | inaryfunc|        | __rmatmul__  |
| ultiply|                   |                   |              |
+----------------------------+-------------------+--------------+
| |:c.PyNumberMethods.nb_in  | |:c.binaryfunc:b  | __matmul__   |
| place_matrix_multiply:nb_  | inaryfunc|        |              |
| inplace_matrix_multiply|   |                   |              |
+----------------------------+-------------------+--------------+
|                                                               |
+----------------------------+-------------------+--------------+
| |:c.PyMappingMethods.mp_l  | |:c.lenfunc:lenf  | __len__      |
| ength:mp_length|           | unc|              |              |
+----------------------------+-------------------+--------------+
| |:c.PyMappingMethods.mp_s  | |:c.binaryfunc:b  | __getitem__  |
| ubscript:mp_subscript|     | inaryfunc|        |              |
+----------------------------+-------------------+--------------+
| |:c.PyMappingMethods.mp_a  | |:c.objobjargpro  | __setitem__, |
| ss_subscript:mp_ass_subsc  | c:objobjargproc|  | __delitem__  |
| ript|                      |                   |              |
+----------------------------+-------------------+--------------+
|                                                               |
+----------------------------+-------------------+--------------+
| |:c.PySequenceMethods.sq_  | |:c.lenfunc:lenf  | __len__      |
| length:sq_length|          | unc|              |              |
+----------------------------+-------------------+--------------+
| |:c.PySequenceMethods.sq_  | |:c.binaryfunc:b  | __add__      |
| concat:sq_concat|          | inaryfunc|        |              |
+----------------------------+-------------------+--------------+
| |:c.PySequenceMethods.sq_  | |:c.ssizeargfunc  | __mul__      |
| repeat:sq_repeat|          | :ssizeargfunc|    |              |
+----------------------------+-------------------+--------------+
| |:c.PySequenceMethods.sq_  | |:c.ssizeargfunc  | __getitem__  |
| item:sq_item|              | :ssizeargfunc|    |              |
+----------------------------+-------------------+--------------+
| |:c.PySequenceMethods.sq_  | |:c.ssizeobjargp  | __setitem__  |
| ass_item:sq_ass_item|      | roc:ssizeobjargp  | __delitem__  |
|                            | roc|              |              |
+----------------------------+-------------------+--------------+
| |:c.PySequenceMethods.sq_  | |:c.objobjproc:o  | __contains__ |
| contains:sq_contains|      | bjobjproc|        |              |
+----------------------------+-------------------+--------------+
| |:c.PySequenceMethods.sq_  | |:c.binaryfunc:b  | __iadd__     |
| inplace_concat:sq_inplace  | inaryfunc|        |              |
| _concat|                   |                   |              |
+----------------------------+-------------------+--------------+
| |:c.PySequenceMethods.sq_  | |:c.ssizeargfunc  | __imul__     |
| inplace_repeat:sq_inplace  | :ssizeargfunc|    |              |
| _repeat|                   |                   |              |
+----------------------------+-------------------+--------------+
|                                                               |
+----------------------------+-------------------+--------------+
| |:c.PyBufferProcs.bf_getb  | |:c.getbufferpro  |              |
| uffer:bf_getbuffer|        | c:getbufferproc(  |              |
|                            | )|                |              |
+----------------------------+-------------------+--------------+
| |:c.PyBufferProcs.bf_rele  | |:c.releasebuffe  |              |
| asebuffer:bf_releasebuffe  | rproc:releasebuf  |              |
| r|                         | ferproc()|        |              |
+----------------------------+-------------------+--------------+

*|slot-typedefs-table:⚓|* ## slot-typedefs:slot typedefs

+-------------------------------+-------------------------------+------------------------+
| typedef                       | Parameter Types               | Return Type            |
|===============================|===============================|========================|
| |:c.allocfunc:allocfunc|      | |:c-api/type.txt/c.PyTypeObj  | |:c-api/structures.tx  |
|                               | ect:PyTypeObject| *           | t/c.PyObject:PyObject| |
|                               | Py_ssize_t                    | *                      |
+-------------------------------+-------------------------------+------------------------+
| |:c.destructor:destructor|    | void *                        | void                   |
+-------------------------------+-------------------------------+------------------------+
| |:c.freefunc:freefunc|        | void *                        | void                   |
+-------------------------------+-------------------------------+------------------------+
| |:c-api/gcsupport.txt/c.trav  | void * |:c-api/gcsupport.txt  | int                    |
| erseproc:traverseproc|        | /c.visitproc:visitproc| void  |                        |
|                               | *                             |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.newfunc:newfunc|          | |:c-api/structures.txt/c.PyO  | |:c-api/structures.tx  |
|                               | bject:PyObject| * |:c-api/st  | t/c.PyObject:PyObject| |
|                               | ructures.txt/c.PyObject:PyOb  | *                      |
|                               | ject| * |:c-api/structures.t  |                        |
|                               | xt/c.PyObject:PyObject| *     |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.initproc:initproc|        | |:c-api/structures.txt/c.PyO  | int                    |
|                               | bject:PyObject| * |:c-api/st  |                        |
|                               | ructures.txt/c.PyObject:PyOb  |                        |
|                               | ject| * |:c-api/structures.t  |                        |
|                               | xt/c.PyObject:PyObject| *     |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.reprfunc:reprfunc|        | |:c-api/structures.txt/c.PyO  | |:c-api/structures.tx  |
|                               | bject:PyObject| *             | t/c.PyObject:PyObject| |
|                               |                               | *                      |
+-------------------------------+-------------------------------+------------------------+
| |:c.getattrfunc:getattrfunc|  | |:c-api/structures.txt/c.PyO  | |:c-api/structures.tx  |
|                               | bject:PyObject| * const char  | t/c.PyObject:PyObject| |
|                               | *                             | *                      |
+-------------------------------+-------------------------------+------------------------+
| |:c.setattrfunc:setattrfunc|  | |:c-api/structures.txt/c.PyO  | int                    |
|                               | bject:PyObject| * const char  |                        |
|                               | * |:c-api/structures.txt/c.P  |                        |
|                               | yObject:PyObject| *           |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.getattrofunc:getattrofun  | |:c-api/structures.txt/c.PyO  | |:c-api/structures.tx  |
| c|                            | bject:PyObject| * |:c-api/st  | t/c.PyObject:PyObject| |
|                               | ructures.txt/c.PyObject:PyOb  | *                      |
|                               | ject| *                       |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.setattrofunc:setattrofun  | |:c-api/structures.txt/c.PyO  | int                    |
| c|                            | bject:PyObject| * |:c-api/st  |                        |
|                               | ructures.txt/c.PyObject:PyOb  |                        |
|                               | ject| * |:c-api/structures.t  |                        |
|                               | xt/c.PyObject:PyObject| *     |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.descrgetfunc:descrgetfun  | |:c-api/structures.txt/c.PyO  | |:c-api/structures.tx  |
| c|                            | bject:PyObject| * |:c-api/st  | t/c.PyObject:PyObject| |
|                               | ructures.txt/c.PyObject:PyOb  | *                      |
|                               | ject| * |:c-api/structures.t  |                        |
|                               | xt/c.PyObject:PyObject| *     |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.descrsetfunc:descrsetfun  | |:c-api/structures.txt/c.PyO  | int                    |
| c|                            | bject:PyObject| * |:c-api/st  |                        |
|                               | ructures.txt/c.PyObject:PyOb  |                        |
|                               | ject| * |:c-api/structures.t  |                        |
|                               | xt/c.PyObject:PyObject| *     |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.hashfunc:hashfunc|        | |:c-api/structures.txt/c.PyO  | Py_hash_t              |
|                               | bject:PyObject| *             |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.richcmpfunc:richcmpfunc|  | |:c-api/structures.txt/c.PyO  | |:c-api/structures.tx  |
|                               | bject:PyObject| * |:c-api/st  | t/c.PyObject:PyObject| |
|                               | ructures.txt/c.PyObject:PyOb  | *                      |
|                               | ject| * int                   |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.getiterfunc:getiterfunc|  | |:c-api/structures.txt/c.PyO  | |:c-api/structures.tx  |
|                               | bject:PyObject| *             | t/c.PyObject:PyObject| |
|                               |                               | *                      |
+-------------------------------+-------------------------------+------------------------+
| |:c.iternextfunc:iternextfun  | |:c-api/structures.txt/c.PyO  | |:c-api/structures.tx  |
| c|                            | bject:PyObject| *             | t/c.PyObject:PyObject| |
|                               |                               | *                      |
+-------------------------------+-------------------------------+------------------------+
| |:c.lenfunc:lenfunc|          | |:c-api/structures.txt/c.PyO  | Py_ssize_t             |
|                               | bject:PyObject| *             |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.getbufferproc:getbufferp  | |:c-api/structures.txt/c.PyO  | int                    |
| roc|                          | bject:PyObject| * |:c-api/bu  |                        |
|                               | ffer.txt/c.Py_buffer:Py_buff  |                        |
|                               | er| * int                     |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.releasebufferproc:releas  | |:c-api/structures.txt/c.PyO  | void                   |
| ebufferproc|                  | bject:PyObject| * |:c-api/bu  |                        |
|                               | ffer.txt/c.Py_buffer:Py_buff  |                        |
|                               | er| *                         |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c-api/gcsupport.txt/c.inqu  | void *                        | int                    |
| iry:inquiry|                  |                               |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.unaryfunc:unaryfunc|      | |:c-api/structures.txt/c.PyO  | |:c-api/structures.tx  |
|                               | bject:PyObject| *             | t/c.PyObject:PyObject| |
|                               |                               | *                      |
+-------------------------------+-------------------------------+------------------------+
| |:c.binaryfunc:binaryfunc|    | |:c-api/structures.txt/c.PyO  | |:c-api/structures.tx  |
|                               | bject:PyObject| * |:c-api/st  | t/c.PyObject:PyObject| |
|                               | ructures.txt/c.PyObject:PyOb  | *                      |
|                               | ject| *                       |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.ternaryfunc:ternaryfunc|  | |:c-api/structures.txt/c.PyO  | |:c-api/structures.tx  |
|                               | bject:PyObject| * |:c-api/st  | t/c.PyObject:PyObject| |
|                               | ructures.txt/c.PyObject:PyOb  | *                      |
|                               | ject| * |:c-api/structures.t  |                        |
|                               | xt/c.PyObject:PyObject| *     |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.ssizeargfunc:ssizeargfun  | |:c-api/structures.txt/c.PyO  | |:c-api/structures.tx  |
| c|                            | bject:PyObject| * Py_ssize_t  | t/c.PyObject:PyObject| |
|                               |                               | *                      |
+-------------------------------+-------------------------------+------------------------+
| |:c.ssizeobjargproc:ssizeobj  | |:c-api/structures.txt/c.PyO  | int                    |
| argproc|                      | bject:PyObject| * Py_ssize_t  |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.objobjproc:objobjproc|    | |:c-api/structures.txt/c.PyO  | int                    |
|                               | bject:PyObject| * |:c-api/st  |                        |
|                               | ructures.txt/c.PyObject:PyOb  |                        |
|                               | ject| *                       |                        |
+-------------------------------+-------------------------------+------------------------+
| |:c.objobjargproc:objobjargp  | |:c-api/structures.txt/c.PyO  | int                    |
| roc|                          | bject:PyObject| * |:c-api/st  |                        |
|                               | ructures.txt/c.PyObject:PyOb  |                        |
|                               | ject| * |:c-api/structures.t  |                        |
|                               | xt/c.PyObject:PyObject| *     |                        |
+-------------------------------+-------------------------------+------------------------+

See |:id5:Slot Type typedefs| below for more detail.

# pytypeobject-definition:PyTypeObject Definition

The structure definition for |:c-api/type.txt/c.PyTypeObject:PyTypeObject| can be found in "Include/object.h".
For convenience of reference, this repeats the definition found there:

```rst
typedef struct _typeobject {
    PyObject_VAR_HEAD
    const char *tp_name; /* For printing, in format "<module>.<name>" */
    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */

    /* Methods to implement standard operations */

    destructor tp_dealloc;
    Py_ssize_t tp_vectorcall_offset;
    getattrfunc tp_getattr;
    setattrfunc tp_setattr;
    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)
                                    or tp_reserved (Python 3) */
    reprfunc tp_repr;

    /* Method suites for standard classes */

    PyNumberMethods *tp_as_number;
    PySequenceMethods *tp_as_sequence;
    PyMappingMethods *tp_as_mapping;

    /* More standard operations (here for binary compatibility) */

    hashfunc tp_hash;
    ternaryfunc tp_call;
    reprfunc tp_str;
    getattrofunc tp_getattro;
    setattrofunc tp_setattro;

    /* Functions to access object as input/output buffer */
    PyBufferProcs *tp_as_buffer;

    /* Flags to define presence of optional/expanded features */
    unsigned long tp_flags;

    const char *tp_doc; /* Documentation string */

    /* call function for all accessible objects */
    traverseproc tp_traverse;

    /* delete references to contained objects */
    inquiry tp_clear;

    /* rich comparisons */
    richcmpfunc tp_richcompare;

    /* weak reference enabler */
    Py_ssize_t tp_weaklistoffset;

    /* Iterators */
    getiterfunc tp_iter;
    iternextfunc tp_iternext;

    /* Attribute descriptor and subclassing stuff */
    struct PyMethodDef *tp_methods;
    struct PyMemberDef *tp_members;
    struct PyGetSetDef *tp_getset;
    struct _typeobject *tp_base;
    PyObject *tp_dict;
    descrgetfunc tp_descr_get;
    descrsetfunc tp_descr_set;
    Py_ssize_t tp_dictoffset;
    initproc tp_init;
    allocfunc tp_alloc;
    newfunc tp_new;
    freefunc tp_free; /* Low-level free-memory routine */
    inquiry tp_is_gc; /* For PyObject_IS_GC */
    PyObject *tp_bases;
    PyObject *tp_mro; /* method resolution order */
    PyObject *tp_cache;
    PyObject *tp_subclasses;
    PyObject *tp_weaklist;
    destructor tp_del;

    /* Type attribute cache version tag. Added in version 2.6 */
    unsigned int tp_version_tag;

    destructor tp_finalize;

} PyTypeObject;

```

# pyobject-slots:PyObject Slots

The type object structure extends the |:c-api/structures.txt/c.PyVarObject:PyVarObject| structure. The "ob_size"
field is used for dynamic types (created by  "type_new()", usually called from a
class statement). Note that |:c-api/type.txt/c.PyType_Type:PyType_Type| (the metatype) initializes
|:c.PyTypeObject.tp_itemsize:tp_itemsize|, which means that its instances (i.e. type objects) *must* have
the "ob_size" field.

*c.PyObject._ob_next:|:c-api/structures.txt/c.PyObject:PyObject| *|:c-api/structures.txt/c.PyObject:PyObject|._ob_next
*
*c.PyObject._ob_prev:|:c-api/structures.txt/c.PyObject:PyObject| *|:c-api/structures.txt/c.PyObject:PyObject|._ob_prev
*

   These fields are only present when the macro "Py_TRACE_REFS" is defined. Their
   initialization to "NULL" is taken care of by the "PyObject_HEAD_INIT" macro.
   For statically allocated objects, these fields always remain "NULL". For
   dynamically allocated objects, these two fields are used to link the object into
   a doubly-linked list of *all* live objects on the heap.  This could be used for
   various debugging purposes; currently the only use is to print the objects that
   are still alive at the end of a run when the environment variable *|index-0:⚓|*
   |:using/cmdline.txt/envvar-PYTHONDUMPREFS:PYTHONDUMPREFS| is set.

   *Inheritance:*

   These fields are not inherited by subtypes.

*c.PyObject.ob_refcnt:Py_ssize_t |:c-api/structures.txt/c.PyObject:PyObject|.ob_refcnt
*

   This is the type object’s reference count, initialized to "1" by the "
   PyObject_HEAD_INIT" macro.  Note that for statically allocated type objects, the
   type’s instances (objects whose "ob_type" points back to the type) do *not*
   count as references.  But for dynamically allocated type objects, the instances
   *do* count as references.

   *Inheritance:*

   This field is not inherited by subtypes.

*c.PyObject.ob_type:|:c-api/type.txt/c.PyTypeObject:PyTypeObject| *|:c-api/structures.txt/c.PyObject:PyObject|.ob_type
*

   This is the type’s type, in other words its metatype.  It is initialized by the
   argument to the "PyObject_HEAD_INIT" macro, and its value should normally be "
   &PyType_Type".  However, for dynamically loadable extension modules that must be
   usable on Windows (at least), the compiler complains that this is not a valid
   initializer.  Therefore, the convention is to pass "NULL" to the "
   PyObject_HEAD_INIT" macro and to initialize this field explicitly at the start
   of the module’s initialization function, before doing anything else.  This is
   typically done like this:

```rst
Foo_Type.ob_type = &PyType_Type;
```

   This should be done before any instances of the type are created.
   |:c-api/type.txt/c.PyType_Ready:PyType_Ready()| checks if "ob_type" is "NULL", and if so, initializes it to the
   "ob_type" field of the base class. |:c-api/type.txt/c.PyType_Ready:PyType_Ready()| will not change this field
   if it is non-zero.

   *Inheritance:*

   This field is inherited by subtypes.

# pyvarobject-slots:PyVarObject Slots

*c.PyVarObject.ob_size:Py_ssize_t |:c-api/structures.txt/c.PyVarObject:PyVarObject|.ob_size
*

   For statically allocated type objects, this should be initialized to zero.  For
   dynamically allocated type objects, this field has a special internal meaning.

   *Inheritance:*

   This field is not inherited by subtypes.

# pytypeobject-slots:PyTypeObject Slots

Each slot has a section describing inheritance.  If |:c-api/type.txt/c.PyType_Ready:PyType_Ready()| may set a
value when the field is set to "NULL" then there will also be a “Default”
section.  (Note that many fields set on "PyBaseObject_Type" and |:c-api/type.txt/c.PyType_Type:PyType_Type|
effectively act as defaults.)

*c.PyTypeObject.tp_name:const char *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_name
*

   Pointer to a NUL-terminated string containing the name of the type. For types
   that are accessible as module globals, the string should be the full module
   name, followed by a dot, followed by the type name; for built-in types, it
   should be just the type name.  If the module is a submodule of a package, the
   full package name is part of the full module name.  For example, a type named "T
   " defined in module "M" in subpackage "Q" in package "P" should have the
   |:c.PyTypeObject.tp_name:tp_name| initializer ""P.Q.M.T"".

   For dynamically allocated type objects, this should just be the type name, and
   the module name explicitly stored in the type dict as the value for key "
   '__module__'".

   For statically allocated type objects, the tp_name field should contain a dot.
   Everything before the last dot is made accessible as the "__module__" attribute,
   and everything after the last dot is made accessible as the |:library/stdtypes.txt/definition.__name__:__name__|
   attribute.

   If no dot is present, the entire |:c.PyTypeObject.tp_name:tp_name| field is made accessible as the
   |:library/stdtypes.txt/definition.__name__:__name__| attribute, and the "__module__" attribute is undefined (unless
   explicitly set in the dictionary, as explained above).  This means your type
   will be impossible to pickle.  Additionally, it will not be listed in module
   documentations created with pydoc.

   This field must not be "NULL".  It is the only required field in
   |:c-api/type.txt/c.PyTypeObject:PyTypeObject()| (other than potentially |:c.PyTypeObject.tp_itemsize:tp_itemsize|).

   *Inheritance:*

   This field is not inherited by subtypes.

*c.PyTypeObject.tp_basicsize:Py_ssize_t |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_basicsize
*
*c.PyTypeObject.tp_itemsize:Py_ssize_t |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_itemsize
*

   These fields allow calculating the size in bytes of instances of the type.

   There are two kinds of types: types with fixed-length instances have a zero
   |:c.PyTypeObject.tp_itemsize:tp_itemsize| field, types with variable-length instances have a non-zero
   |:c.PyTypeObject.tp_itemsize:tp_itemsize| field.  For a type with fixed-length instances, all instances have
   the same size, given in |:c.PyTypeObject.tp_basicsize:tp_basicsize|.

   For a type with variable-length instances, the instances must have an "ob_size"
   field, and the instance size is |:c.PyTypeObject.tp_basicsize:tp_basicsize| plus N times |:c.PyTypeObject.tp_itemsize:tp_itemsize|, where
   N is the “length” of the object.  The value of N is typically stored in the
   instance’s "ob_size" field.  There are exceptions:  for example, ints use a
   negative "ob_size" to indicate a negative number, and N is "abs(ob_size)" there.
   Also, the presence of an "ob_size" field in the instance layout doesn’t mean
   that the instance structure is variable-length (for example, the structure for
   the list type has fixed-length instances, yet those instances have a meaningful
   "ob_size" field).

   The basic size includes the fields in the instance declared by the macro
   |:c-api/structures.txt/c.PyObject_HEAD:PyObject_HEAD| or |:c-api/structures.txt/c.PyObject_VAR_HEAD:PyObject_VAR_HEAD| (whichever is used to declare the
   instance struct) and this in turn includes the "_ob_prev" and "_ob_next" fields
   if they are present.  This means that the only correct way to get an initializer
   for the |:c.PyTypeObject.tp_basicsize:tp_basicsize| is to use the "sizeof" operator on the struct used to
   declare the instance layout. The basic size does not include the GC header size.

   A note about alignment: if the variable items require a particular alignment,
   this should be taken care of by the value of |:c.PyTypeObject.tp_basicsize:tp_basicsize|.  Example: suppose a
   type implements an array of "double". |:c.PyTypeObject.tp_itemsize:tp_itemsize| is "sizeof(double)". It is
   the programmer’s responsibility that |:c.PyTypeObject.tp_basicsize:tp_basicsize| is a multiple of "
   sizeof(double)" (assuming this is the alignment requirement for "double").

   For any type with variable-length instances, this field must not be "NULL".

   *Inheritance:*

   These fields are inherited separately by subtypes.  If the base type has a non-
   zero |:c.PyTypeObject.tp_itemsize:tp_itemsize|, it is generally not safe to set |:c.PyTypeObject.tp_itemsize:tp_itemsize| to a different
   non-zero value in a subtype (though this depends on the implementation of the
   base type).

*c.PyTypeObject.tp_dealloc:|:c.destructor:destructor| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_dealloc
*

   A pointer to the instance destructor function.  This function must be defined
   unless the type guarantees that its instances will never be deallocated (as is
   the case for the singletons "None" and "Ellipsis").  The function signature is:

```rst
void tp_dealloc(PyObject *self);
```

   The destructor function is called by the |:c-api/refcounting.txt/c.Py_DECREF:Py_DECREF()| and |:c-api/refcounting.txt/c.Py_XDECREF:Py_XDECREF()| macros
   when the new reference count is zero.  At this point, the instance is still in
   existence, but there are no references to it.  The destructor function should
   free all references which the instance owns, free all memory buffers owned by
   the instance (using the freeing function corresponding to the allocation
   function used to allocate the buffer), and call the type’s |:c.PyTypeObject.tp_free:tp_free| function.
   If the type is not subtypable (doesn’t have the |:Py_TPFLAGS_BASETYPE:Py_TPFLAGS_BASETYPE| flag bit
   set), it is permissible to call the object deallocator directly instead of via
   |:c.PyTypeObject.tp_free:tp_free|.  The object deallocator should be the one used to allocate the
   instance; this is normally |:c-api/allocation.txt/c.PyObject_Del:PyObject_Del()| if the instance was allocated using
   |:c-api/allocation.txt/c.PyObject_New:PyObject_New()| or "PyObject_VarNew()", or |:c-api/gcsupport.txt/c.PyObject_GC_Del:PyObject_GC_Del()| if the instance
   was allocated using |:c-api/gcsupport.txt/c.PyObject_GC_New:PyObject_GC_New()| or |:c-api/gcsupport.txt/c.PyObject_GC_NewVar:PyObject_GC_NewVar()|.

   Finally, if the type is heap allocated (|:Py_TPFLAGS_HEAPTYPE:Py_TPFLAGS_HEAPTYPE|), the deallocator
   should decrement the reference count for its type object after calling the type
   deallocator. In order to avoid dangling pointers, the recommended way to achieve
   this is:

```rst
static void foo_dealloc(foo_object *self) {
    PyTypeObject *tp = Py_TYPE(self);
    // free references and buffers here
    tp->tp_free(self);
    Py_DECREF(tp);
}
```

   *Inheritance:*

   This field is inherited by subtypes.

*c.PyTypeObject.tp_vectorcall_offset:Py_ssize_t |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_vectorcall_offset
*

   An optional offset to a per-instance function that implements calling the object
   using the *vectorcall* protocol, a more efficient alternative of the simpler
   |:c.PyTypeObject.tp_call:tp_call|.

   This field is only used if the flag |:Py_TPFLAGS_HAVE_VECTORCALL:_Py_TPFLAGS_HAVE_VECTORCALL| is set. If so,
   this must be a positive integer containing the offset in the instance of a
   |:c.vectorcallfunc:vectorcallfunc| pointer. The signature is the same as for
   |:c-api/object.txt/c._PyObject_Vectorcall:_PyObject_Vectorcall()|:

```rst
PyObject *vectorcallfunc(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)
```

   The *vectorcallfunc* pointer may be zero, in which case the instance behaves as
   if |:Py_TPFLAGS_HAVE_VECTORCALL:_Py_TPFLAGS_HAVE_VECTORCALL| was not set: calling the instance falls back to
   |:c.PyTypeObject.tp_call:tp_call|.

   Any class that sets "_Py_TPFLAGS_HAVE_VECTORCALL" must also set |:c.PyTypeObject.tp_call:tp_call| and
   make sure its behaviour is consistent with the *vectorcallfunc* function. This
   can be done by setting *tp_call* to "PyVectorcall_Call":

   *c.PyTypeObject.tp_vectorcall_offset.PyVectorcall_Call:|:c-api/structures.txt/c.PyObject:PyObject| *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
   *

      Call *callable*’s *vectorcallfunc* with positional and keyword arguments given
      in a tuple and dict, respectively.

      This function is intended to be used in the "tp_call" slot. It does not fall
      back to "tp_call" and it currently does not check the "
      _Py_TPFLAGS_HAVE_VECTORCALL" flag. To call an object, use one of the
      |:c-api/object.txt/c.PyObject_Call:PyObject_Call| functions instead.

   Note:

     It is not recommended for |:heap-types:heap types| to implement the vectorcall protocol.
     When a user sets "__call__" in Python code, only "tp_call" is updated, possibly
     making it inconsistent with the vectorcall function.

   Note:

     The semantics of the "tp_vectorcall_offset" slot are provisional and expected to
     be finalized in Python 3.9. If you use vectorcall, plan for updating your code
     for Python 3.9.

   Changed in version 3.8: This slot was used for print formatting in Python 2.x.
   In Python 3.0 to 3.7, it was reserved and named "tp_print".

   *Inheritance:*

   This field is inherited by subtypes together with |:c.PyTypeObject.tp_call:tp_call|: a subtype inherits
   |:c.PyTypeObject.tp_vectorcall_offset:tp_vectorcall_offset| from its base type when the subtype’s |:c.PyTypeObject.tp_call:tp_call| is "NULL"
   .

   Note that |:id4:heap types| (including subclasses defined in Python) do not inherit
   the |:Py_TPFLAGS_HAVE_VECTORCALL:_Py_TPFLAGS_HAVE_VECTORCALL| flag.

*c.PyTypeObject.tp_getattr:|:c.getattrfunc:getattrfunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_getattr
*

   An optional pointer to the get-attribute-string function.

   This field is deprecated.  When it is defined, it should point to a function
   that acts the same as the |:c.PyTypeObject.tp_getattro:tp_getattro| function, but taking a C string instead
   of a Python string object to give the attribute name.

   *Inheritance:*

   Group: "tp_getattr", "tp_getattro"

   This field is inherited by subtypes together with |:c.PyTypeObject.tp_getattro:tp_getattro|: a subtype
   inherits both |:c.PyTypeObject.tp_getattr:tp_getattr| and |:c.PyTypeObject.tp_getattro:tp_getattro| from its base type when the
   subtype’s |:c.PyTypeObject.tp_getattr:tp_getattr| and |:c.PyTypeObject.tp_getattro:tp_getattro| are both "NULL".

*c.PyTypeObject.tp_setattr:|:c.setattrfunc:setattrfunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_setattr
*

   An optional pointer to the function for setting and deleting attributes.

   This field is deprecated.  When it is defined, it should point to a function
   that acts the same as the |:c.PyTypeObject.tp_setattro:tp_setattro| function, but taking a C string instead
   of a Python string object to give the attribute name.

   *Inheritance:*

   Group: "tp_setattr", "tp_setattro"

   This field is inherited by subtypes together with |:c.PyTypeObject.tp_setattro:tp_setattro|: a subtype
   inherits both |:c.PyTypeObject.tp_setattr:tp_setattr| and |:c.PyTypeObject.tp_setattro:tp_setattro| from its base type when the
   subtype’s |:c.PyTypeObject.tp_setattr:tp_setattr| and |:c.PyTypeObject.tp_setattro:tp_setattro| are both "NULL".

*c.PyTypeObject.tp_as_async:|:c.PyAsyncMethods:PyAsyncMethods| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_as_async
*

   Pointer to an additional structure that contains fields relevant only to objects
   which implement |:glossary.txt/term-awaitable:awaitable| and |:glossary.txt/term-asynchronous-iterator:asynchronous iterator| protocols at the
   C-level.  See |:async-structs:Async Object Structures| for details.

   New in version 3.5: Formerly known as "tp_compare" and "tp_reserved".

   *Inheritance:*

   The |:c.PyTypeObject.tp_as_async:tp_as_async| field is not inherited, but the contained fields are inherited
   individually.

*c.PyTypeObject.tp_repr:|:c.reprfunc:reprfunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_repr
*
    *|index-1:⚓|*

   An optional pointer to a function that implements the built-in function |:library/functions.txt/repr:repr()|
   .

   The signature is the same as for |:c-api/object.txt/c.PyObject_Repr:PyObject_Repr()|:

```rst
PyObject *tp_repr(PyObject *self);
```

   The function must return a string or a Unicode object.  Ideally, this function
   should return a string that, when passed to |:library/functions.txt/eval:eval()|, given a suitable
   environment, returns an object with the same value.  If this is not feasible, it
   should return a string starting with "'<'" and ending with "'>'" from which both
   the type and the value of the object can be deduced.

   *Inheritance:*

   This field is inherited by subtypes.

   *Default:*

   When this field is not set, a string of the form "<%s object at %p>" is
   returned, where "%s" is replaced by the type name, and "%p" by the object’s
   memory address.

*c.PyTypeObject.tp_as_number:|:c.PyNumberMethods:PyNumberMethods| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_as_number
*

   Pointer to an additional structure that contains fields relevant only to objects
   which implement the number protocol.  These fields are documented in
   |:number-structs:Number Object Structures|.

   *Inheritance:*

   The |:c.PyTypeObject.tp_as_number:tp_as_number| field is not inherited, but the contained fields are
   inherited individually.

*c.PyTypeObject.tp_as_sequence:|:c.PySequenceMethods:PySequenceMethods| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_as_sequence
*

   Pointer to an additional structure that contains fields relevant only to objects
   which implement the sequence protocol.  These fields are documented in
   |:sequence-structs:Sequence Object Structures|.

   *Inheritance:*

   The |:c.PyTypeObject.tp_as_sequence:tp_as_sequence| field is not inherited, but the contained fields are
   inherited individually.

*c.PyTypeObject.tp_as_mapping:|:c.PyMappingMethods:PyMappingMethods| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_as_mapping
*

   Pointer to an additional structure that contains fields relevant only to objects
   which implement the mapping protocol.  These fields are documented in
   |:mapping-structs:Mapping Object Structures|.

   *Inheritance:*

   The |:c.PyTypeObject.tp_as_mapping:tp_as_mapping| field is not inherited, but the contained fields are
   inherited individually.

*c.PyTypeObject.tp_hash:|:c.hashfunc:hashfunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_hash
*
    *|index-2:⚓|*

   An optional pointer to a function that implements the built-in function |:library/functions.txt/hash:hash()|
   .

   The signature is the same as for |:c-api/object.txt/c.PyObject_Hash:PyObject_Hash()|:

```rst
Py_hash_t tp_hash(PyObject *);
```

   The value "-1" should not be returned as a normal return value; when an error
   occurs during the computation of the hash value, the function should set an
   exception and return "-1".

   When this field is not set (*and* "tp_richcompare" is not set), an attempt to
   take the hash of the object raises |:library/exceptions.txt/TypeError:TypeError|. This is the same as setting it
   to |:c-api/object.txt/c.PyObject_HashNotImplemented:PyObject_HashNotImplemented()|.

   This field can be set explicitly to |:c-api/object.txt/c.PyObject_HashNotImplemented:PyObject_HashNotImplemented()| to block
   inheritance of the hash method from a parent type. This is interpreted as the
   equivalent of "__hash__ = None" at the Python level, causing "isinstance(o,
   collections.Hashable)" to correctly return "False". Note that the converse is
   also true - setting "__hash__ = None" on a class at the Python level will result
   in the "tp_hash" slot being set to |:c-api/object.txt/c.PyObject_HashNotImplemented:PyObject_HashNotImplemented()|.

   *Inheritance:*

   Group: "tp_hash", "tp_richcompare"

   This field is inherited by subtypes together with |:c.PyTypeObject.tp_richcompare:tp_richcompare|: a subtype
   inherits both of |:c.PyTypeObject.tp_richcompare:tp_richcompare| and |:c.PyTypeObject.tp_hash:tp_hash|, when the subtype’s
   |:c.PyTypeObject.tp_richcompare:tp_richcompare| and |:c.PyTypeObject.tp_hash:tp_hash| are both "NULL".

*c.PyTypeObject.tp_call:|:c.ternaryfunc:ternaryfunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_call
*

   An optional pointer to a function that implements calling the object.  This
   should be "NULL" if the object is not callable.  The signature is the same as
   for |:c-api/object.txt/c.PyObject_Call:PyObject_Call()|:

```rst
PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);
```

   *Inheritance:*

   This field is inherited by subtypes.

*c.PyTypeObject.tp_str:|:c.reprfunc:reprfunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_str
*

   An optional pointer to a function that implements the built-in operation |:library/stdtypes.txt/str:str()|
   .  (Note that |:library/stdtypes.txt/str:str| is a type now, and |:library/stdtypes.txt/str:str()| calls the constructor for that
   type.  This constructor calls |:c-api/object.txt/c.PyObject_Str:PyObject_Str()| to do the actual work, and
   |:c-api/object.txt/c.PyObject_Str:PyObject_Str()| will call this handler.)

   The signature is the same as for |:c-api/object.txt/c.PyObject_Str:PyObject_Str()|:

```rst
PyObject *tp_str(PyObject *self);
```

   The function must return a string or a Unicode object.  It should be a
   “friendly” string representation of the object, as this is the representation
   that will be used, among other things, by the |:library/functions.txt/print:print()| function.

   *Inheritance:*

   This field is inherited by subtypes.

   *Default:*

   When this field is not set, |:c-api/object.txt/c.PyObject_Repr:PyObject_Repr()| is called to return a string
   representation.

*c.PyTypeObject.tp_getattro:|:c.getattrofunc:getattrofunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_getattro
*

   An optional pointer to the get-attribute function.

   The signature is the same as for |:c-api/object.txt/c.PyObject_GetAttr:PyObject_GetAttr()|:

```rst
PyObject *tp_getattro(PyObject *self, PyObject *attr);
```

   It is usually convenient to set this field to |:c-api/object.txt/c.PyObject_GenericGetAttr:PyObject_GenericGetAttr()|, which
   implements the normal way of looking for object attributes.

   *Inheritance:*

   Group: "tp_getattr", "tp_getattro"

   This field is inherited by subtypes together with |:c.PyTypeObject.tp_getattr:tp_getattr|: a subtype
   inherits both |:c.PyTypeObject.tp_getattr:tp_getattr| and |:c.PyTypeObject.tp_getattro:tp_getattro| from its base type when the
   subtype’s |:c.PyTypeObject.tp_getattr:tp_getattr| and |:c.PyTypeObject.tp_getattro:tp_getattro| are both "NULL".

   *Default:*

   "PyBaseObject_Type" uses |:c-api/object.txt/c.PyObject_GenericGetAttr:PyObject_GenericGetAttr()|.

*c.PyTypeObject.tp_setattro:|:c.setattrofunc:setattrofunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_setattro
*

   An optional pointer to the function for setting and deleting attributes.

   The signature is the same as for |:c-api/object.txt/c.PyObject_SetAttr:PyObject_SetAttr()|:

```rst
PyObject *tp_setattro(PyObject *self, PyObject *attr, PyObject *value);
```

   In addition, setting *value* to "NULL" to delete an attribute must be supported.
   It is usually convenient to set this field to |:c-api/object.txt/c.PyObject_GenericSetAttr:PyObject_GenericSetAttr()|, which
   implements the normal way of setting object attributes.

   *Inheritance:*

   Group: "tp_setattr", "tp_setattro"

   This field is inherited by subtypes together with |:c.PyTypeObject.tp_setattr:tp_setattr|: a subtype
   inherits both |:c.PyTypeObject.tp_setattr:tp_setattr| and |:c.PyTypeObject.tp_setattro:tp_setattro| from its base type when the
   subtype’s |:c.PyTypeObject.tp_setattr:tp_setattr| and |:c.PyTypeObject.tp_setattro:tp_setattro| are both "NULL".

   *Default:*

   "PyBaseObject_Type" uses |:c-api/object.txt/c.PyObject_GenericSetAttr:PyObject_GenericSetAttr()|.

*c.PyTypeObject.tp_as_buffer:|:c.PyBufferProcs:PyBufferProcs| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_as_buffer
*

   Pointer to an additional structure that contains fields relevant only to objects
   which implement the buffer interface.  These fields are documented in
   |:buffer-structs:Buffer Object Structures|.

   *Inheritance:*

   The |:c.PyTypeObject.tp_as_buffer:tp_as_buffer| field is not inherited, but the contained fields are
   inherited individually.

*c.PyTypeObject.tp_flags:unsigned long |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_flags
*

   This field is a bit mask of various flags.  Some flags indicate variant
   semantics for certain situations; others are used to indicate that certain
   fields in the type object (or in the extension structures referenced via
   |:c.PyTypeObject.tp_as_number:tp_as_number|, |:c.PyTypeObject.tp_as_sequence:tp_as_sequence|, |:c.PyTypeObject.tp_as_mapping:tp_as_mapping|, and |:c.PyTypeObject.tp_as_buffer:tp_as_buffer|) that were
   historically not always present are valid; if such a flag bit is clear, the type
   fields it guards must not be accessed and must be considered to have a zero or "
   NULL" value instead.

   *Inheritance:*

   Inheritance of this field is complicated.  Most flag bits are inherited
   individually, i.e. if the base type has a flag bit set, the subtype inherits
   this flag bit.  The flag bits that pertain to extension structures are strictly
   inherited if the extension structure is inherited, i.e. the base type’s value of
   the flag bit is copied into the subtype together with a pointer to the extension
   structure.  The |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC| flag bit is inherited together with the
   |:c.PyTypeObject.tp_traverse:tp_traverse| and |:c.PyTypeObject.tp_clear:tp_clear| fields, i.e. if the |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC| flag bit
   is clear in the subtype and the |:c.PyTypeObject.tp_traverse:tp_traverse| and |:c.PyTypeObject.tp_clear:tp_clear| fields in the
   subtype exist and have "NULL" values.

   *Default:*

   "PyBaseObject_Type" uses "Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE".

   *Bit Masks:*

   The following bit masks are currently defined; these can be ORed together using
   the "|" operator to form the value of the |:c.PyTypeObject.tp_flags:tp_flags| field.  The macro
   |:c-api/type.txt/c.PyType_HasFeature:PyType_HasFeature()| takes a type and a flags value, *tp* and *f*, and checks
   whether "tp->tp_flags & f" is non-zero.

   *Py_TPFLAGS_HEAPTYPE:Py_TPFLAGS_HEAPTYPE*

      This bit is set when the type object itself is allocated on the heap, for
      example, types created dynamically using |:c-api/type.txt/c.PyType_FromSpec:PyType_FromSpec()|.  In this case, the
      "ob_type" field of its instances is considered a reference to the type, and the
      type object is INCREF’ed when a new instance is created, and DECREF’ed when an
      instance is destroyed (this does not apply to instances of subtypes; only the
      type referenced by the instance’s ob_type gets INCREF’ed or DECREF’ed).

      *Inheritance:*

      ???

   *Py_TPFLAGS_BASETYPE:Py_TPFLAGS_BASETYPE*

      This bit is set when the type can be used as the base type of another type.  If
      this bit is clear, the type cannot be subtyped (similar to a “final” class in
      Java).

      *Inheritance:*

      ???

   *Py_TPFLAGS_READY:Py_TPFLAGS_READY*

      This bit is set when the type object has been fully initialized by
      |:c-api/type.txt/c.PyType_Ready:PyType_Ready()|.

      *Inheritance:*

      ???

   *Py_TPFLAGS_READYING:Py_TPFLAGS_READYING*

      This bit is set while |:c-api/type.txt/c.PyType_Ready:PyType_Ready()| is in the process of initializing the
      type object.

      *Inheritance:*

      ???

   *Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC*

      This bit is set when the object supports garbage collection.  If this bit is
      set, instances must be created using |:c-api/gcsupport.txt/c.PyObject_GC_New:PyObject_GC_New()| and destroyed using
      |:c-api/gcsupport.txt/c.PyObject_GC_Del:PyObject_GC_Del()|.  More information in section
      |:c-api/gcsupport.txt/supporting-cycle-detection:Supporting Cyclic Garbage Collection|.  This bit also implies that the GC-
      related fields |:c.PyTypeObject.tp_traverse:tp_traverse| and |:c.PyTypeObject.tp_clear:tp_clear| are present in the type object.

      *Inheritance:*

      Group: |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC|, "tp_traverse", "tp_clear"

      The |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC| flag bit is inherited together with the "tp_traverse"
      and "tp_clear" fields, i.e.  if the |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC| flag bit is clear in
      the subtype and the "tp_traverse" and "tp_clear" fields in the subtype exist and
      have "NULL" values.

   *Py_TPFLAGS_DEFAULT:Py_TPFLAGS_DEFAULT*

      This is a bitmask of all the bits that pertain to the existence of certain
      fields in the type object and its extension structures. Currently, it includes
      the following bits: "Py_TPFLAGS_HAVE_STACKLESS_EXTENSION", "
      Py_TPFLAGS_HAVE_VERSION_TAG".

      *Inheritance:*

      ???

   *Py_TPFLAGS_METHOD_DESCRIPTOR:Py_TPFLAGS_METHOD_DESCRIPTOR*

      This bit indicates that objects behave like unbound methods.

      If this flag is set for "type(meth)", then:

      * "meth.__get__(obj, cls)(*args, **kwds)" (with "obj" not None) must be equivalent
        to "meth(obj, *args, **kwds)".

      * "meth.__get__(None, cls)(*args, **kwds)" must be equivalent to "meth(*args,
        **kwds)".

      This flag enables an optimization for typical method calls like "obj.meth()": it
      avoids creating a temporary “bound method” object for "obj.meth".

      New in version 3.8.

      *Inheritance:*

      This flag is never inherited by heap types. For extension types, it is inherited
      whenever |:c.PyTypeObject.tp_descr_get:tp_descr_get| is inherited.

   *Py_TPFLAGS_LONG_SUBCLASS:Py_TPFLAGS_LONG_SUBCLASS*

   *Py_TPFLAGS_LIST_SUBCLASS:Py_TPFLAGS_LIST_SUBCLASS*

   *Py_TPFLAGS_TUPLE_SUBCLASS:Py_TPFLAGS_TUPLE_SUBCLASS*

   *Py_TPFLAGS_BYTES_SUBCLASS:Py_TPFLAGS_BYTES_SUBCLASS*

   *Py_TPFLAGS_UNICODE_SUBCLASS:Py_TPFLAGS_UNICODE_SUBCLASS*

   *Py_TPFLAGS_DICT_SUBCLASS:Py_TPFLAGS_DICT_SUBCLASS*

   *Py_TPFLAGS_BASE_EXC_SUBCLASS:Py_TPFLAGS_BASE_EXC_SUBCLASS*

   *Py_TPFLAGS_TYPE_SUBCLASS:Py_TPFLAGS_TYPE_SUBCLASS*

      These flags are used by functions such as |:c-api/long.txt/c.PyLong_Check:PyLong_Check()| to quickly determine
      if a type is a subclass of a built-in type; such specific checks are faster than
      a generic check, like |:c-api/object.txt/c.PyObject_IsInstance:PyObject_IsInstance()|. Custom types that inherit from
      built-ins should have their |:c.PyTypeObject.tp_flags:tp_flags| set appropriately, or the code that
      interacts with such types will behave differently depending on what kind of
      check is used.

   *Py_TPFLAGS_HAVE_FINALIZE:Py_TPFLAGS_HAVE_FINALIZE*

      This bit is set when the |:c.PyTypeObject.tp_finalize:tp_finalize| slot is present in the type structure.

      New in version 3.4.

      Deprecated since version 3.8: This flag isn’t necessary anymore, as the
      interpreter assumes the |:c.PyTypeObject.tp_finalize:tp_finalize| slot is always present in the type
      structure.

   *Py_TPFLAGS_HAVE_VECTORCALL:_Py_TPFLAGS_HAVE_VECTORCALL*

      This bit is set when the class implements the vectorcall protocol. See
      |:c.PyTypeObject.tp_vectorcall_offset:tp_vectorcall_offset| for details.

      *Inheritance:*

      This bit is set on *static* subtypes if "tp_flags" is not overridden: a subtype
      inherits "_Py_TPFLAGS_HAVE_VECTORCALL" from its base type when the subtype’s
      |:c.PyTypeObject.tp_call:tp_call| is "NULL" and the subtype’s "Py_TPFLAGS_HEAPTYPE" is not set.

      |:id4:Heap types| do not inherit "_Py_TPFLAGS_HAVE_VECTORCALL".

      Note:

        This flag is provisional and expected to become public in Python 3.9, with a
        different name and, possibly, changed semantics. If you use vectorcall, plan for
        updating your code for Python 3.9.

      New in version 3.8.

*c.PyTypeObject.tp_doc:const char *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_doc
*

   An optional pointer to a NUL-terminated C string giving the docstring for this
   type object.  This is exposed as the "__doc__" attribute on the type and
   instances of the type.

   *Inheritance:*

   This field is *not* inherited by subtypes.

*c.PyTypeObject.tp_traverse:|:c-api/gcsupport.txt/c.traverseproc:traverseproc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_traverse
*

   An optional pointer to a traversal function for the garbage collector.  This is
   only used if the |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC| flag bit is set.  The signature is:

```rst
int tp_traverse(PyObject *self, visitproc visit, void *arg);
```

   More information about Python’s garbage collection scheme can be found in
   section |:c-api/gcsupport.txt/supporting-cycle-detection:Supporting Cyclic Garbage Collection|.

   The |:c.PyTypeObject.tp_traverse:tp_traverse| pointer is used by the garbage collector to detect reference
   cycles. A typical implementation of a |:c.PyTypeObject.tp_traverse:tp_traverse| function simply calls
   |:c-api/gcsupport.txt/c.Py_VISIT:Py_VISIT()| on each of the instance’s members that are Python objects that the
   instance owns. For example, this is function "local_traverse()" from the
   |:library/_thread.txt/module-_thread:_thread| extension module:

```rst
static int
local_traverse(localobject *self, visitproc visit, void *arg)
{
    Py_VISIT(self->args);
    Py_VISIT(self->kw);
    Py_VISIT(self->dict);
    return 0;
}
```

   Note that |:c-api/gcsupport.txt/c.Py_VISIT:Py_VISIT()| is called only on those members that can participate in
   reference cycles.  Although there is also a "self->key" member, it can only be "
   NULL" or a Python string and therefore cannot be part of a reference cycle.

   On the other hand, even if you know a member can never be part of a cycle, as a
   debugging aid you may want to visit it anyway just so the |:library/gc.txt/module-gc:gc| module’s
   |:library/gc.txt/gc.get_referents:get_referents()| function will include it.

   Warning:

     When implementing |:c.PyTypeObject.tp_traverse:tp_traverse|, only the members that the instance *owns* (by
     having strong references to them) must be visited. For instance, if an object
     supports weak references via the |:c.PyTypeObject.tp_weaklist:tp_weaklist| slot, the pointer supporting the
     linked list (what *tp_weaklist* points to) must *not* be visited as the instance
     does not directly own the weak references to itself (the weakreference list is
     there to support the weak reference machinery, but the instance has no strong
     reference to the elements inside it, as they are allowed to be removed even if
     the instance is still alive).

   Note that |:c-api/gcsupport.txt/c.Py_VISIT:Py_VISIT()| requires the *visit* and *arg* parameters to "
   local_traverse()" to have these specific names; don’t name them just anything.

   *Inheritance:*

   Group: |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC|, "tp_traverse", "tp_clear"

   This field is inherited by subtypes together with |:c.PyTypeObject.tp_clear:tp_clear| and the
   |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC| flag bit: the flag bit, |:c.PyTypeObject.tp_traverse:tp_traverse|, and |:c.PyTypeObject.tp_clear:tp_clear| are
   all inherited from the base type if they are all zero in the subtype.

*c.PyTypeObject.tp_clear:|:c-api/gcsupport.txt/c.inquiry:inquiry| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_clear
*

   An optional pointer to a clear function for the garbage collector. This is only
   used if the |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC| flag bit is set.  The signature is:

```rst
int tp_clear(PyObject *);
```

   The |:c.PyTypeObject.tp_clear:tp_clear| member function is used to break reference cycles in cyclic
   garbage detected by the garbage collector.  Taken together, all |:c.PyTypeObject.tp_clear:tp_clear|
   functions in the system must combine to break all reference cycles.  This is
   subtle, and if in any doubt supply a |:c.PyTypeObject.tp_clear:tp_clear| function.  For example, the
   tuple type does not implement a |:c.PyTypeObject.tp_clear:tp_clear| function, because it’s possible to
   prove that no reference cycle can be composed entirely of tuples. Therefore the
   |:c.PyTypeObject.tp_clear:tp_clear| functions of other types must be sufficient to break any cycle
   containing a tuple.  This isn’t immediately obvious, and there’s rarely a good
   reason to avoid implementing |:c.PyTypeObject.tp_clear:tp_clear|.

   Implementations of |:c.PyTypeObject.tp_clear:tp_clear| should drop the instance’s references to those of
   its members that may be Python objects, and set its pointers to those members to
   "NULL", as in the following example:

```rst
static int
local_clear(localobject *self)
{
    Py_CLEAR(self->key);
    Py_CLEAR(self->args);
    Py_CLEAR(self->kw);
    Py_CLEAR(self->dict);
    return 0;
}
```

   The |:c-api/refcounting.txt/c.Py_CLEAR:Py_CLEAR()| macro should be used, because clearing references is delicate:
   the reference to the contained object must not be decremented until after the
   pointer to the contained object is set to "NULL".  This is because decrementing
   the reference count may cause the contained object to become trash, triggering a
   chain of reclamation activity that may include invoking arbitrary Python code
   (due to finalizers, or weakref callbacks, associated with the contained object).
   If it’s possible for such code to reference *self* again, it’s important that
   the pointer to the contained object be "NULL" at that time, so that *self* knows
   the contained object can no longer be used.  The |:c-api/refcounting.txt/c.Py_CLEAR:Py_CLEAR()| macro performs the
   operations in a safe order.

   Because the goal of |:c.PyTypeObject.tp_clear:tp_clear| functions is to break reference cycles, it’s not
   necessary to clear contained objects like Python strings or Python integers,
   which can’t participate in reference cycles. On the other hand, it may be
   convenient to clear all contained Python objects, and write the type’s
   |:c.PyTypeObject.tp_dealloc:tp_dealloc| function to invoke |:c.PyTypeObject.tp_clear:tp_clear|.

   More information about Python’s garbage collection scheme can be found in
   section |:c-api/gcsupport.txt/supporting-cycle-detection:Supporting Cyclic Garbage Collection|.

   *Inheritance:*

   Group: |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC|, "tp_traverse", "tp_clear"

   This field is inherited by subtypes together with |:c.PyTypeObject.tp_traverse:tp_traverse| and the
   |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC| flag bit: the flag bit, |:c.PyTypeObject.tp_traverse:tp_traverse|, and |:c.PyTypeObject.tp_clear:tp_clear| are
   all inherited from the base type if they are all zero in the subtype.

*c.PyTypeObject.tp_richcompare:|:c.richcmpfunc:richcmpfunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_richcompare
*

   An optional pointer to the rich comparison function, whose signature is:

```rst
PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);
```

   The first parameter is guaranteed to be an instance of the type that is defined
   by |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.

   The function should return the result of the comparison (usually "Py_True" or "
   Py_False").  If the comparison is undefined, it must return "Py_NotImplemented",
   if another error occurred it must return "NULL" and set an exception condition.

   The following constants are defined to be used as the third argument for
   |:c.PyTypeObject.tp_richcompare:tp_richcompare| and for |:c-api/object.txt/c.PyObject_RichCompare:PyObject_RichCompare()|:

   +------------------+--------------+
   | Constant         | Comparison   |
   |==================|==============|
   | "Py_LT"          | "<"          |
   +------------------+--------------+
   | "Py_LE"          | "<="         |
   +------------------+--------------+
   | "Py_EQ"          | "=="         |
   +------------------+--------------+
   | "Py_NE"          | "!="         |
   +------------------+--------------+
   | "Py_GT"          | ">"          |
   +------------------+--------------+
   | "Py_GE"          | ">="         |
   +------------------+--------------+

   The following macro is defined to ease writing rich comparison functions:

   *c.PyTypeObject.tp_richcompare.Py_RETURN_RICHCOMPARE:Py_RETURN_RICHCOMPARE(VAL_A, VAL_B, op)
   *

      Return "Py_True" or "Py_False" from the function, depending on the result of a
      comparison. VAL_A and VAL_B must be orderable by C comparison operators (for
      example, they may be C ints or floats). The third argument specifies the
      requested operation, as for |:c-api/object.txt/c.PyObject_RichCompare:PyObject_RichCompare()|.

      The return value’s reference count is properly incremented.

      On error, sets an exception and returns "NULL" from the function.

      New in version 3.7.

   *Inheritance:*

   Group: "tp_hash", "tp_richcompare"

   This field is inherited by subtypes together with |:c.PyTypeObject.tp_hash:tp_hash|: a subtype inherits
   |:c.PyTypeObject.tp_richcompare:tp_richcompare| and |:c.PyTypeObject.tp_hash:tp_hash| when the subtype’s |:c.PyTypeObject.tp_richcompare:tp_richcompare| and |:c.PyTypeObject.tp_hash:tp_hash|
   are both "NULL".

   *Default:*

   "PyBaseObject_Type" provides a "tp_richcompare" implementation, which may be
   inherited.  However, if only "tp_hash" is defined, not even the inherited
   function is used and instances of the type will not be able to participate in
   any comparisons.

*c.PyTypeObject.tp_weaklistoffset:Py_ssize_t |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_weaklistoffset
*

   If the instances of this type are weakly referenceable, this field is greater
   than zero and contains the offset in the instance structure of the weak
   reference list head (ignoring the GC header, if present); this offset is used by
   "PyObject_ClearWeakRefs()" and the *PyWeakref_** functions.  The instance
   structure needs to include a field of type *|:c-api/structures.txt/c.PyObject:PyObject|** which is initialized to
   "NULL".

   Do not confuse this field with |:c.PyTypeObject.tp_weaklist:tp_weaklist|; that is the list head for weak
   references to the type object itself.

   *Inheritance:*

   This field is inherited by subtypes, but see the rules listed below. A subtype
   may override this offset; this means that the subtype uses a different weak
   reference list head than the base type.  Since the list head is always found via
   |:c.PyTypeObject.tp_weaklistoffset:tp_weaklistoffset|, this should not be a problem.

   When a type defined by a class statement has no |:reference/datamodel.txt/object.__slots__:__slots__| declaration, and
   none of its base types are weakly referenceable, the type is made weakly
   referenceable by adding a weak reference list head slot to the instance layout
   and setting the |:c.PyTypeObject.tp_weaklistoffset:tp_weaklistoffset| of that slot’s offset.

   When a type’s "__slots__" declaration contains a slot named "__weakref__", that
   slot becomes the weak reference list head for instances of the type, and the
   slot’s offset is stored in the type’s |:c.PyTypeObject.tp_weaklistoffset:tp_weaklistoffset|.

   When a type’s "__slots__" declaration does not contain a slot named "__weakref__
   ", the type inherits its |:c.PyTypeObject.tp_weaklistoffset:tp_weaklistoffset| from its base type.

*c.PyTypeObject.tp_iter:|:c.getiterfunc:getiterfunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_iter
*

   An optional pointer to a function that returns an iterator for the object.  Its
   presence normally signals that the instances of this type are iterable (although
   sequences may be iterable without this function).

   This function has the same signature as |:c-api/object.txt/c.PyObject_GetIter:PyObject_GetIter()|:

```rst
PyObject *tp_iter(PyObject *self);
```

   *Inheritance:*

   This field is inherited by subtypes.

*c.PyTypeObject.tp_iternext:|:c.iternextfunc:iternextfunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_iternext
*

   An optional pointer to a function that returns the next item in an iterator. The
   signature is:

```rst
PyObject *tp_iternext(PyObject *self);
```

   When the iterator is exhausted, it must return "NULL"; a |:library/exceptions.txt/StopIteration:StopIteration|
   exception may or may not be set.  When another error occurs, it must return "
   NULL" too.  Its presence signals that the instances of this type are iterators.

   Iterator types should also define the |:c.PyTypeObject.tp_iter:tp_iter| function, and that function
   should return the iterator instance itself (not a new iterator instance).

   This function has the same signature as |:c-api/iter.txt/c.PyIter_Next:PyIter_Next()|.

   *Inheritance:*

   This field is inherited by subtypes.

*c.PyTypeObject.tp_methods:struct |:c-api/structures.txt/c.PyMethodDef:PyMethodDef| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_methods
*

   An optional pointer to a static "NULL"-terminated array of |:c-api/structures.txt/c.PyMethodDef:PyMethodDef|
   structures, declaring regular methods of this type.

   For each entry in the array, an entry is added to the type’s dictionary (see
   |:c.PyTypeObject.tp_dict:tp_dict| below) containing a method descriptor.

   *Inheritance:*

   This field is not inherited by subtypes (methods are inherited through a
   different mechanism).

*c.PyTypeObject.tp_members:struct |:c-api/structures.txt/c.PyMemberDef:PyMemberDef| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_members
*

   An optional pointer to a static "NULL"-terminated array of |:c-api/structures.txt/c.PyMemberDef:PyMemberDef|
   structures, declaring regular data members (fields or slots) of instances of
   this type.

   For each entry in the array, an entry is added to the type’s dictionary (see
   |:c.PyTypeObject.tp_dict:tp_dict| below) containing a member descriptor.

   *Inheritance:*

   This field is not inherited by subtypes (members are inherited through a
   different mechanism).

*c.PyTypeObject.tp_getset:struct |:c-api/structures.txt/c.PyGetSetDef:PyGetSetDef| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_getset
*

   An optional pointer to a static "NULL"-terminated array of |:c-api/structures.txt/c.PyGetSetDef:PyGetSetDef|
   structures, declaring computed attributes of instances of this type.

   For each entry in the array, an entry is added to the type’s dictionary (see
   |:c.PyTypeObject.tp_dict:tp_dict| below) containing a getset descriptor.

   *Inheritance:*

   This field is not inherited by subtypes (computed attributes are inherited
   through a different mechanism).

*c.PyTypeObject.tp_base:|:c-api/type.txt/c.PyTypeObject:PyTypeObject| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_base
*

   An optional pointer to a base type from which type properties are inherited.  At
   this level, only single inheritance is supported; multiple inheritance require
   dynamically creating a type object by calling the metatype.

   Note:

     Slot initialization is subject to the rules of initializing globals. C99
     requires the initializers to be “address constants”.  Function designators like
     |:c-api/type.txt/c.PyType_GenericNew:PyType_GenericNew()|, with implicit conversion to a pointer, are valid C99
     address constants.However, the unary ‘&’ operator applied to a non-static
     variable like "PyBaseObject_Type()" is not required to produce an address
     constant.  Compilers may support this (gcc does), MSVC does not. Both compilers
     are strictly standard conforming in this particular behavior.Consequently,
     |:c.PyTypeObject.tp_base:tp_base| should be set in the extension module’s init function.

   *Inheritance:*

   This field is not inherited by subtypes (obviously).

   *Default:*

   This field defaults to "&PyBaseObject_Type" (which to Python programmers is
   known as the type |:library/functions.txt/object:object|).

*c.PyTypeObject.tp_dict:|:c-api/structures.txt/c.PyObject:PyObject| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_dict
*

   The type’s dictionary is stored here by |:c-api/type.txt/c.PyType_Ready:PyType_Ready()|.

   This field should normally be initialized to "NULL" before PyType_Ready is
   called; it may also be initialized to a dictionary containing initial attributes
   for the type.  Once |:c-api/type.txt/c.PyType_Ready:PyType_Ready()| has initialized the type, extra attributes
   for the type may be added to this dictionary only if they don’t correspond to
   overloaded operations (like "__add__()").

   *Inheritance:*

   This field is not inherited by subtypes (though the attributes defined in here
   are inherited through a different mechanism).

   *Default:*

   If this field is "NULL", |:c-api/type.txt/c.PyType_Ready:PyType_Ready()| will assign a new dictionary to it.

   Warning:

     It is not safe to use |:c-api/dict.txt/c.PyDict_SetItem:PyDict_SetItem()| on or otherwise modify |:c.PyTypeObject.tp_dict:tp_dict| with
     the dictionary C-API.

*c.PyTypeObject.tp_descr_get:|:c.descrgetfunc:descrgetfunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_descr_get
*

   An optional pointer to a “descriptor get” function.

   The function signature is:

```rst
PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);
```

   *Inheritance:*

   This field is inherited by subtypes.

*c.PyTypeObject.tp_descr_set:|:c.descrsetfunc:descrsetfunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_descr_set
*

   An optional pointer to a function for setting and deleting a descriptor’s value.

   The function signature is:

```rst
int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);
```

   The *value* argument is set to "NULL" to delete the value.

   *Inheritance:*

   This field is inherited by subtypes.

*c.PyTypeObject.tp_dictoffset:Py_ssize_t |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_dictoffset
*

   If the instances of this type have a dictionary containing instance variables,
   this field is non-zero and contains the offset in the instances of the type of
   the instance variable dictionary; this offset is used by
   |:c-api/object.txt/c.PyObject_GenericGetAttr:PyObject_GenericGetAttr()|.

   Do not confuse this field with |:c.PyTypeObject.tp_dict:tp_dict|; that is the dictionary for attributes
   of the type object itself.

   If the value of this field is greater than zero, it specifies the offset from
   the start of the instance structure.  If the value is less than zero, it
   specifies the offset from the *end* of the instance structure.  A negative
   offset is more expensive to use, and should only be used when the instance
   structure contains a variable-length part.  This is used for example to add an
   instance variable dictionary to subtypes of |:library/stdtypes.txt/str:str| or |:library/stdtypes.txt/tuple:tuple|. Note that the
   |:c.PyTypeObject.tp_basicsize:tp_basicsize| field should account for the dictionary added to the end in that
   case, even though the dictionary is not included in the basic object layout.  On
   a system with a pointer size of 4 bytes, |:c.PyTypeObject.tp_dictoffset:tp_dictoffset| should be set to "-4"
   to indicate that the dictionary is at the very end of the structure.

   The real dictionary offset in an instance can be computed from a negative
   |:c.PyTypeObject.tp_dictoffset:tp_dictoffset| as follows:

```rst
dictoffset = tp_basicsize + abs(ob_size)*tp_itemsize + tp_dictoffset
if dictoffset is not aligned on sizeof(void*):
    round up to sizeof(void*)
```

   where |:c.PyTypeObject.tp_basicsize:tp_basicsize|, |:c.PyTypeObject.tp_itemsize:tp_itemsize| and |:c.PyTypeObject.tp_dictoffset:tp_dictoffset| are taken from the type
   object, and "ob_size" is taken from the instance.  The absolute value is taken
   because ints use the sign of "ob_size" to store the sign of the number.
   (There’s never a need to do this calculation yourself; it is done for you by "
   _PyObject_GetDictPtr()".)

   *Inheritance:*

   This field is inherited by subtypes, but see the rules listed below. A subtype
   may override this offset; this means that the subtype instances store the
   dictionary at a difference offset than the base type.  Since the dictionary is
   always found via |:c.PyTypeObject.tp_dictoffset:tp_dictoffset|, this should not be a problem.

   When a type defined by a class statement has no |:reference/datamodel.txt/object.__slots__:__slots__| declaration, and
   none of its base types has an instance variable dictionary, a dictionary slot is
   added to the instance layout and the |:c.PyTypeObject.tp_dictoffset:tp_dictoffset| is set to that slot’s
   offset.

   When a type defined by a class statement has a "__slots__" declaration, the type
   inherits its |:c.PyTypeObject.tp_dictoffset:tp_dictoffset| from its base type.

   (Adding a slot named |:library/stdtypes.txt/object.__dict__:__dict__| to the "__slots__" declaration does not have the
   expected effect, it just causes confusion.  Maybe this should be added as a
   feature just like "__weakref__" though.)

   *Default:*

   This slot has no default.  For static types, if the field is "NULL" then no "
   __dict__" gets created for instances.

*c.PyTypeObject.tp_init:|:c.initproc:initproc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_init
*

   An optional pointer to an instance initialization function.

   This function corresponds to the "__init__()" method of classes.  Like "
   __init__()", it is possible to create an instance without calling "__init__()",
   and it is possible to reinitialize an instance by calling its "__init__()"
   method again.

   The function signature is:

```rst
int tp_init(PyObject *self, PyObject *args, PyObject *kwds);
```

   The self argument is the instance to be initialized; the *args* and *kwds*
   arguments represent positional and keyword arguments of the call to "__init__()"
   .

   The |:c.PyTypeObject.tp_init:tp_init| function, if not "NULL", is called when an instance is created
   normally by calling its type, after the type’s |:c.PyTypeObject.tp_new:tp_new| function has returned an
   instance of the type.  If the |:c.PyTypeObject.tp_new:tp_new| function returns an instance of some
   other type that is not a subtype of the original type, no |:c.PyTypeObject.tp_init:tp_init| function is
   called; if |:c.PyTypeObject.tp_new:tp_new| returns an instance of a subtype of the original type, the
   subtype’s |:c.PyTypeObject.tp_init:tp_init| is called.

   Returns "0" on success, "-1" and sets an exception on error.

   *Inheritance:*

   This field is inherited by subtypes.

   *Default:*

   For static types this field does not have a default.

*c.PyTypeObject.tp_alloc:|:c.allocfunc:allocfunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_alloc
*

   An optional pointer to an instance allocation function.

   The function signature is:

```rst
PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);
```

   *Inheritance:*

   This field is inherited by static subtypes, but not by dynamic subtypes
   (subtypes created by a class statement).

   *Default:*

   For dynamic subtypes, this field is always set to |:c-api/type.txt/c.PyType_GenericAlloc:PyType_GenericAlloc()|, to
   force a standard heap allocation strategy.

   For static subtypes, "PyBaseObject_Type" uses |:c-api/type.txt/c.PyType_GenericAlloc:PyType_GenericAlloc()|.  That is
   the recommended value for all statically defined types.

*c.PyTypeObject.tp_new:|:c.newfunc:newfunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_new
*

   An optional pointer to an instance creation function.

   The function signature is:

```rst
PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);
```

   The subtype argument is the type of the object being created; the *args* and *
   kwds* arguments represent positional and keyword arguments of the call to the
   type.  Note that subtype doesn’t have to equal the type whose |:c.PyTypeObject.tp_new:tp_new| function
   is called; it may be a subtype of that type (but not an unrelated type).

   The |:c.PyTypeObject.tp_new:tp_new| function should call "subtype->tp_alloc(subtype, nitems)" to
   allocate space for the object, and then do only as much further initialization
   as is absolutely necessary.  Initialization that can safely be ignored or
   repeated should be placed in the |:c.PyTypeObject.tp_init:tp_init| handler.  A good rule of thumb is
   that for immutable types, all initialization should take place in |:c.PyTypeObject.tp_new:tp_new|,
   while for mutable types, most initialization should be deferred to |:c.PyTypeObject.tp_init:tp_init|.

   *Inheritance:*

   This field is inherited by subtypes, except it is not inherited by static types
   whose |:c.PyTypeObject.tp_base:tp_base| is "NULL" or "&PyBaseObject_Type".

   *Default:*

   For static types this field has no default.  This means if the slot is defined
   as "NULL", the type cannot be called to create new instances; presumably there
   is some other way to create instances, like a factory function.

*c.PyTypeObject.tp_free:|:c.freefunc:freefunc| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_free
*

   An optional pointer to an instance deallocation function.  Its signature is:

```rst
void tp_free(void *self);
```

   An initializer that is compatible with this signature is |:c-api/memory.txt/c.PyObject_Free:PyObject_Free()|.

   *Inheritance:*

   This field is inherited by static subtypes, but not by dynamic subtypes
   (subtypes created by a class statement)

   *Default:*

   In dynamic subtypes, this field is set to a deallocator suitable to match
   |:c-api/type.txt/c.PyType_GenericAlloc:PyType_GenericAlloc()| and the value of the |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC| flag bit.

   For static subtypes, "PyBaseObject_Type" uses PyObject_Del.

*c.PyTypeObject.tp_is_gc:|:c-api/gcsupport.txt/c.inquiry:inquiry| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_is_gc
*

   An optional pointer to a function called by the garbage collector.

   The garbage collector needs to know whether a particular object is collectible
   or not.  Normally, it is sufficient to look at the object’s type’s |:c.PyTypeObject.tp_flags:tp_flags|
   field, and check the |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC| flag bit.  But some types have a
   mixture of statically and dynamically allocated instances, and the statically
   allocated instances are not collectible.  Such types should define this
   function; it should return "1" for a collectible instance, and "0" for a non-
   collectible instance. The signature is:

```rst
int tp_is_gc(PyObject *self);
```

   (The only example of this are types themselves.  The metatype, |:c-api/type.txt/c.PyType_Type:PyType_Type|,
   defines this function to distinguish between statically and dynamically
   allocated types.)

   *Inheritance:*

   This field is inherited by subtypes.

   *Default:*

   This slot has no default.  If this field is "NULL", |:Py_TPFLAGS_HAVE_GC:Py_TPFLAGS_HAVE_GC| is used
   as the functional equivalent.

*c.PyTypeObject.tp_bases:|:c-api/structures.txt/c.PyObject:PyObject| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_bases
*

   Tuple of base types.

   This is set for types created by a class statement.  It should be "NULL" for
   statically defined types.

   *Inheritance:*

   This field is not inherited.

*c.PyTypeObject.tp_mro:|:c-api/structures.txt/c.PyObject:PyObject| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_mro
*

   Tuple containing the expanded set of base types, starting with the type itself
   and ending with |:library/functions.txt/object:object|, in Method Resolution Order.

   *Inheritance:*

   This field is not inherited; it is calculated fresh by |:c-api/type.txt/c.PyType_Ready:PyType_Ready()|.

*c.PyTypeObject.tp_cache:|:c-api/structures.txt/c.PyObject:PyObject| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_cache
*

   Unused.  Internal use only.

   *Inheritance:*

   This field is not inherited.

*c.PyTypeObject.tp_subclasses:|:c-api/structures.txt/c.PyObject:PyObject| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_subclasses
*

   List of weak references to subclasses.  Internal use only.

   *Inheritance:*

   This field is not inherited.

*c.PyTypeObject.tp_weaklist:|:c-api/structures.txt/c.PyObject:PyObject| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_weaklist
*

   Weak reference list head, for weak references to this type object.  Not
   inherited.  Internal use only.

   *Inheritance:*

   This field is not inherited.

*c.PyTypeObject.tp_del:|:c.destructor:destructor| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_del
*

   This field is deprecated.  Use |:c.PyTypeObject.tp_finalize:tp_finalize| instead.

*c.PyTypeObject.tp_version_tag:unsigned int |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_version_tag
*

   Used to index into the method cache.  Internal use only.

   *Inheritance:*

   This field is not inherited.

*c.PyTypeObject.tp_finalize:|:c.destructor:destructor| |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_finalize
*

   An optional pointer to an instance finalization function.  Its signature is:

```rst
void tp_finalize(PyObject *self);
```

   If |:c.PyTypeObject.tp_finalize:tp_finalize| is set, the interpreter calls it once when finalizing an
   instance.  It is called either from the garbage collector (if the instance is
   part of an isolated reference cycle) or just before the object is deallocated.
   Either way, it is guaranteed to be called before attempting to break reference
   cycles, ensuring that it finds the object in a sane state.

   |:c.PyTypeObject.tp_finalize:tp_finalize| should not mutate the current exception status; therefore, a
   recommended way to write a non-trivial finalizer is:

```rst
static void
local_finalize(PyObject *self)
{
    PyObject *error_type, *error_value, *error_traceback;

    /* Save the current exception, if any. */
    PyErr_Fetch(&error_type, &error_value, &error_traceback);

    /* ... */

    /* Restore the saved exception. */
    PyErr_Restore(error_type, error_value, error_traceback);
}
```

   For this field to be taken into account (even through inheritance), you must
   also set the |:Py_TPFLAGS_HAVE_FINALIZE:Py_TPFLAGS_HAVE_FINALIZE| flags bit.

   *Inheritance:*

   This field is inherited by subtypes.

   New in version 3.4.

   See also:

     “Safe object finalization” (*|index-3:⚓|* |:www.python.org/dev/peps/pep-0442:PEP 442|)

The remaining fields are only defined if the feature test macro "COUNT_ALLOCS"
is defined, and are for internal use only. They are documented here for
completeness.  None of these fields are inherited by subtypes.

*c.PyTypeObject.tp_allocs:Py_ssize_t |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_allocs
*

   Number of allocations.

*c.PyTypeObject.tp_frees:Py_ssize_t |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_frees
*

   Number of frees.

*c.PyTypeObject.tp_maxalloc:Py_ssize_t |:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_maxalloc
*

   Maximum simultaneously allocated objects.

*c.PyTypeObject.tp_prev:|:c-api/type.txt/c.PyTypeObject:PyTypeObject| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_prev
*

   Pointer to the previous type object with a non-zero |:c.PyTypeObject.tp_allocs:tp_allocs| field.

*c.PyTypeObject.tp_next:|:c-api/type.txt/c.PyTypeObject:PyTypeObject| *|:c-api/type.txt/c.PyTypeObject:PyTypeObject|.tp_next
*

   Pointer to the next type object with a non-zero |:c.PyTypeObject.tp_allocs:tp_allocs| field.

Also, note that, in a garbage collected Python, |:c.PyTypeObject.tp_dealloc:tp_dealloc| may be called from
any Python thread, not just the thread which created the object (if the object
becomes part of a refcount cycle, that cycle might be collected by a garbage
collection on any thread).  This is not a problem for Python API calls, since
the thread on which tp_dealloc is called will own the Global Interpreter Lock
(GIL). However, if the object being destroyed in turn destroys objects from some
other C or C++ library, care should be taken to ensure that destroying those
objects on the thread which called tp_dealloc will not violate any assumptions
of the library.

*|heap-types:⚓|* # heap-types:Heap Types

Traditionally, types defined in C code are *static*, that is, a static
|:c-api/type.txt/c.PyTypeObject:PyTypeObject| structure is defined directly in code and initialized using
|:c-api/type.txt/c.PyType_Ready:PyType_Ready()|.

This results in types that are limited relative to types defined in Python:

* Static types are limited to one base, i.e. they cannot use multiple inheritance.

* Static type objects (but not necessarily their instances) are immutable. It is
  not possible to add or modify the type object’s attributes from Python.

* Static type objects are shared across |:c-api/init.txt/sub-interpreter-support:sub-interpreters|, so they should not
  include any subinterpreter-specific state.

Also, since |:c-api/type.txt/c.PyTypeObject:PyTypeObject| is not part of the |:c-api/stable.txt/stable:stable ABI|, any extension
modules using static types must be compiled for a specific Python minor version.

An alternative to static types is *heap-allocated types*, or *heap types* for
short, which correspond closely to classes created by Python’s "class"
statement.

This is done by filling a |:c-api/type.txt/c.PyType_Spec:PyType_Spec| structure and calling
|:c-api/type.txt/c.PyType_FromSpecWithBases:PyType_FromSpecWithBases()|.

*|number-structs:⚓|*  number-object-structures:Number Object Structures

*c.PyNumberMethods:type PyNumberMethods
*

   This structure holds pointers to the functions which an object uses to implement
   the number protocol.  Each function is used by the function of similar name
   documented in the |:c-api/number.txt/number:Number Protocol| section.

   Here is the structure definition:

```rst
typedef struct {
     binaryfunc nb_add;
     binaryfunc nb_subtract;
     binaryfunc nb_multiply;
     binaryfunc nb_remainder;
     binaryfunc nb_divmod;
     ternaryfunc nb_power;
     unaryfunc nb_negative;
     unaryfunc nb_positive;
     unaryfunc nb_absolute;
     inquiry nb_bool;
     unaryfunc nb_invert;
     binaryfunc nb_lshift;
     binaryfunc nb_rshift;
     binaryfunc nb_and;
     binaryfunc nb_xor;
     binaryfunc nb_or;
     unaryfunc nb_int;
     void *nb_reserved;
     unaryfunc nb_float;

     binaryfunc nb_inplace_add;
     binaryfunc nb_inplace_subtract;
     binaryfunc nb_inplace_multiply;
     binaryfunc nb_inplace_remainder;
     ternaryfunc nb_inplace_power;
     binaryfunc nb_inplace_lshift;
     binaryfunc nb_inplace_rshift;
     binaryfunc nb_inplace_and;
     binaryfunc nb_inplace_xor;
     binaryfunc nb_inplace_or;

     binaryfunc nb_floor_divide;
     binaryfunc nb_true_divide;
     binaryfunc nb_inplace_floor_divide;
     binaryfunc nb_inplace_true_divide;

     unaryfunc nb_index;

     binaryfunc nb_matrix_multiply;
     binaryfunc nb_inplace_matrix_multiply;
} PyNumberMethods;
```

   Note:

     Binary and ternary functions must check the type of all their operands, and
     implement the necessary conversions (at least one of the operands is an instance
     of the defined type).  If the operation is not defined for the given operands,
     binary and ternary functions must return "Py_NotImplemented", if another error
     occurred they must return "NULL" and set an exception.

   Note:

     The |:c.PyNumberMethods.nb_reserved:nb_reserved| field should always be "NULL".  It was previously called "
     nb_long", and was renamed in Python 3.0.1.

*c.PyNumberMethods.nb_add:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_add
*

*c.PyNumberMethods.nb_subtract:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_subtract
*

*c.PyNumberMethods.nb_multiply:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_multiply
*

*c.PyNumberMethods.nb_remainder:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_remainder
*

*c.PyNumberMethods.nb_divmod:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_divmod
*

*c.PyNumberMethods.nb_power:|:c.ternaryfunc:ternaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_power
*

*c.PyNumberMethods.nb_negative:|:c.unaryfunc:unaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_negative
*

*c.PyNumberMethods.nb_positive:|:c.unaryfunc:unaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_positive
*

*c.PyNumberMethods.nb_absolute:|:c.unaryfunc:unaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_absolute
*

*c.PyNumberMethods.nb_bool:|:c-api/gcsupport.txt/c.inquiry:inquiry| |:c.PyNumberMethods:PyNumberMethods|.nb_bool
*

*c.PyNumberMethods.nb_invert:|:c.unaryfunc:unaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_invert
*

*c.PyNumberMethods.nb_lshift:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_lshift
*

*c.PyNumberMethods.nb_rshift:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_rshift
*

*c.PyNumberMethods.nb_and:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_and
*

*c.PyNumberMethods.nb_xor:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_xor
*

*c.PyNumberMethods.nb_or:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_or
*

*c.PyNumberMethods.nb_int:|:c.unaryfunc:unaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_int
*

*c.PyNumberMethods.nb_reserved:void *|:c.PyNumberMethods:PyNumberMethods|.nb_reserved
*

*c.PyNumberMethods.nb_float:|:c.unaryfunc:unaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_float
*

*c.PyNumberMethods.nb_inplace_add:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_inplace_add
*

*c.PyNumberMethods.nb_inplace_subtract:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_inplace_subtract
*

*c.PyNumberMethods.nb_inplace_multiply:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_inplace_multiply
*

*c.PyNumberMethods.nb_inplace_remainder:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_inplace_remainder
*

*c.PyNumberMethods.nb_inplace_power:|:c.ternaryfunc:ternaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_inplace_power
*

*c.PyNumberMethods.nb_inplace_lshift:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_inplace_lshift
*

*c.PyNumberMethods.nb_inplace_rshift:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_inplace_rshift
*

*c.PyNumberMethods.nb_inplace_and:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_inplace_and
*

*c.PyNumberMethods.nb_inplace_xor:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_inplace_xor
*

*c.PyNumberMethods.nb_inplace_or:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_inplace_or
*

*c.PyNumberMethods.nb_floor_divide:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_floor_divide
*

*c.PyNumberMethods.nb_true_divide:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_true_divide
*

*c.PyNumberMethods.nb_inplace_floor_divide:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_inplace_floor_divide
*

*c.PyNumberMethods.nb_inplace_true_divide:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_inplace_true_divide
*

*c.PyNumberMethods.nb_index:|:c.unaryfunc:unaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_index
*

*c.PyNumberMethods.nb_matrix_multiply:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_matrix_multiply
*

*c.PyNumberMethods.nb_inplace_matrix_multiply:|:c.binaryfunc:binaryfunc| |:c.PyNumberMethods:PyNumberMethods|.nb_inplace_matrix_multiply
*

*|mapping-structs:⚓|*  mapping-object-structures:Mapping Object Structures

*c.PyMappingMethods:type PyMappingMethods
*

   This structure holds pointers to the functions which an object uses to implement
   the mapping protocol.  It has three members:

*c.PyMappingMethods.mp_length:|:c.lenfunc:lenfunc| |:c.PyMappingMethods:PyMappingMethods|.mp_length
*

   This function is used by |:c-api/mapping.txt/c.PyMapping_Size:PyMapping_Size()| and |:c-api/object.txt/c.PyObject_Size:PyObject_Size()|, and has the
   same signature.  This slot may be set to "NULL" if the object has no defined
   length.

*c.PyMappingMethods.mp_subscript:|:c.binaryfunc:binaryfunc| |:c.PyMappingMethods:PyMappingMethods|.mp_subscript
*

   This function is used by |:c-api/object.txt/c.PyObject_GetItem:PyObject_GetItem()| and |:c-api/sequence.txt/c.PySequence_GetSlice:PySequence_GetSlice()|, and
   has the same signature as *!|:c-api/object.txt/c.PyObject_GetItem:PyObject_GetItem|*.  This slot must be filled for
   the |:c-api/mapping.txt/c.PyMapping_Check:PyMapping_Check()| function to return "1", it can be "NULL" otherwise.

*c.PyMappingMethods.mp_ass_subscript:|:c.objobjargproc:objobjargproc| |:c.PyMappingMethods:PyMappingMethods|.mp_ass_subscript
*

   This function is used by |:c-api/object.txt/c.PyObject_SetItem:PyObject_SetItem()|, |:c-api/object.txt/c.PyObject_DelItem:PyObject_DelItem()|, "
   PyObject_SetSlice()" and "PyObject_DelSlice()".  It has the same signature as *!
   |:c-api/object.txt/c.PyObject_SetItem:PyObject_SetItem|*, but *v* can also be set to "NULL" to delete an item.  If
   this slot is "NULL", the object does not support item assignment and deletion.

*|sequence-structs:⚓|*  sequence-object-structures:Sequence Object Structures

*c.PySequenceMethods:type PySequenceMethods
*

   This structure holds pointers to the functions which an object uses to implement
   the sequence protocol.

*c.PySequenceMethods.sq_length:|:c.lenfunc:lenfunc| |:c.PySequenceMethods:PySequenceMethods|.sq_length
*

   This function is used by |:c-api/sequence.txt/c.PySequence_Size:PySequence_Size()| and |:c-api/object.txt/c.PyObject_Size:PyObject_Size()|, and has the
   same signature.  It is also used for handling negative indices via the |:c.PySequenceMethods.sq_item:sq_item|
   and the |:c.PySequenceMethods.sq_ass_item:sq_ass_item| slots.

*c.PySequenceMethods.sq_concat:|:c.binaryfunc:binaryfunc| |:c.PySequenceMethods:PySequenceMethods|.sq_concat
*

   This function is used by |:c-api/sequence.txt/c.PySequence_Concat:PySequence_Concat()| and has the same signature.  It
   is also used by the "+" operator, after trying the numeric addition via the
   |:c.PyNumberMethods.nb_add:nb_add| slot.

*c.PySequenceMethods.sq_repeat:|:c.ssizeargfunc:ssizeargfunc| |:c.PySequenceMethods:PySequenceMethods|.sq_repeat
*

   This function is used by |:c-api/sequence.txt/c.PySequence_Repeat:PySequence_Repeat()| and has the same signature.  It
   is also used by the "*" operator, after trying numeric multiplication via the
   |:c.PyNumberMethods.nb_multiply:nb_multiply| slot.

*c.PySequenceMethods.sq_item:|:c.ssizeargfunc:ssizeargfunc| |:c.PySequenceMethods:PySequenceMethods|.sq_item
*

   This function is used by |:c-api/sequence.txt/c.PySequence_GetItem:PySequence_GetItem()| and has the same signature.  It
   is also used by |:c-api/object.txt/c.PyObject_GetItem:PyObject_GetItem()|, after trying the subscription via the
   |:c.PyMappingMethods.mp_subscript:mp_subscript| slot. This slot must be filled for the |:c-api/sequence.txt/c.PySequence_Check:PySequence_Check()|
   function to return "1", it can be "NULL" otherwise.

   Negative indexes are handled as follows: if the "sq_length" slot is filled, it
   is called and the sequence length is used to compute a positive index which is
   passed to "sq_item".  If "sq_length" is "NULL", the index is passed as is to the
   function.

*c.PySequenceMethods.sq_ass_item:|:c.ssizeobjargproc:ssizeobjargproc| |:c.PySequenceMethods:PySequenceMethods|.sq_ass_item
*

   This function is used by |:c-api/sequence.txt/c.PySequence_SetItem:PySequence_SetItem()| and has the same signature.  It
   is also used by |:c-api/object.txt/c.PyObject_SetItem:PyObject_SetItem()| and |:c-api/object.txt/c.PyObject_DelItem:PyObject_DelItem()|, after trying the
   item assignment and deletion via the |:c.PyMappingMethods.mp_ass_subscript:mp_ass_subscript| slot. This slot may be
   left to "NULL" if the object does not support item assignment and deletion.

*c.PySequenceMethods.sq_contains:|:c.objobjproc:objobjproc| |:c.PySequenceMethods:PySequenceMethods|.sq_contains
*

   This function may be used by |:c-api/sequence.txt/c.PySequence_Contains:PySequence_Contains()| and has the same signature.
   This slot may be left to "NULL", in this case *!|:c-api/sequence.txt/c.PySequence_Contains:PySequence_Contains|* simply
   traverses the sequence until it finds a match.

*c.PySequenceMethods.sq_inplace_concat:|:c.binaryfunc:binaryfunc| |:c.PySequenceMethods:PySequenceMethods|.sq_inplace_concat
*

   This function is used by |:c-api/sequence.txt/c.PySequence_InPlaceConcat:PySequence_InPlaceConcat()| and has the same
   signature.  It should modify its first operand, and return it.  This slot may be
   left to "NULL", in this case *!|:c-api/sequence.txt/c.PySequence_InPlaceConcat:PySequence_InPlaceConcat|* will fall back to
   |:c-api/sequence.txt/c.PySequence_Concat:PySequence_Concat()|.  It is also used by the augmented assignment "+=", after
   trying numeric in-place addition via the |:c.PyNumberMethods.nb_inplace_add:nb_inplace_add| slot.

*c.PySequenceMethods.sq_inplace_repeat:|:c.ssizeargfunc:ssizeargfunc| |:c.PySequenceMethods:PySequenceMethods|.sq_inplace_repeat
*

   This function is used by |:c-api/sequence.txt/c.PySequence_InPlaceRepeat:PySequence_InPlaceRepeat()| and has the same
   signature.  It should modify its first operand, and return it.  This slot may be
   left to "NULL", in this case *!|:c-api/sequence.txt/c.PySequence_InPlaceRepeat:PySequence_InPlaceRepeat|* will fall back to
   |:c-api/sequence.txt/c.PySequence_Repeat:PySequence_Repeat()|.  It is also used by the augmented assignment "*=", after
   trying numeric in-place multiplication via the |:c.PyNumberMethods.nb_inplace_multiply:nb_inplace_multiply| slot.

*|buffer-structs:⚓|*  buffer-object-structures:Buffer Object Structures

*c.PyBufferProcs:type PyBufferProcs
*

   This structure holds pointers to the functions required by the |:c-api/buffer.txt/bufferobjects:Buffer protocol|
   . The protocol defines how an exporter object can expose its internal data to
   consumer objects.

*c.PyBufferProcs.bf_getbuffer:|:c.getbufferproc:getbufferproc| |:c.PyBufferProcs:PyBufferProcs|.bf_getbuffer
*

   The signature of this function is:

```rst
int (PyObject *exporter, Py_buffer *view, int flags);
```

   Handle a request to *exporter* to fill in *view* as specified by *flags*. Except
   for point (3), an implementation of this function MUST take these steps:

   1. Check if the request can be met. If not, raise "PyExc_BufferError", set *view->
      obj* to "NULL" and return "-1".

   2. Fill in the requested fields.

   3. Increment an internal counter for the number of exports.

   4. Set *view->obj* to *exporter* and increment *view->obj*.

   5. Return "0".

   If *exporter* is part of a chain or tree of buffer providers, two main schemes
   can be used:

   * Re-export: Each member of the tree acts as the exporting object and sets *view->
     obj* to a new reference to itself.

   * Redirect: The buffer request is redirected to the root object of the tree. Here,
     *view->obj* will be a new reference to the root object.

   The individual fields of *view* are described in section |:c-api/buffer.txt/buffer-structure:Buffer structure|, the
   rules how an exporter must react to specific requests are in section
   |:c-api/buffer.txt/buffer-request-types:Buffer request types|.

   All memory pointed to in the |:c-api/buffer.txt/c.Py_buffer:Py_buffer| structure belongs to the exporter and
   must remain valid until there are no consumers left. |:c-api/buffer.txt/c.Py_buffer.format:format|, |:c-api/buffer.txt/c.Py_buffer.shape:shape|,
   |:c-api/buffer.txt/c.Py_buffer.strides:strides|, |:c-api/buffer.txt/c.Py_buffer.suboffsets:suboffsets| and |:c-api/buffer.txt/c.Py_buffer.internal:internal| are read-only for the consumer.

   |:c-api/buffer.txt/c.PyBuffer_FillInfo:PyBuffer_FillInfo()| provides an easy way of exposing a simple bytes buffer
   while dealing correctly with all request types.

   |:c-api/buffer.txt/c.PyObject_GetBuffer:PyObject_GetBuffer()| is the interface for the consumer that wraps this
   function.

*c.PyBufferProcs.bf_releasebuffer:|:c.releasebufferproc:releasebufferproc| |:c.PyBufferProcs:PyBufferProcs|.bf_releasebuffer
*

   The signature of this function is:

```rst
void (PyObject *exporter, Py_buffer *view);
```

   Handle a request to release the resources of the buffer. If no resources need to
   be released, |:c.PyBufferProcs.bf_releasebuffer:PyBufferProcs.bf_releasebuffer| may be "NULL". Otherwise, a
   standard implementation of this function will take these optional steps:

   1. Decrement an internal counter for the number of exports.

   2. If the counter is "0", free all memory associated with *view*.

   The exporter MUST use the |:c-api/buffer.txt/c.Py_buffer.internal:internal| field to keep track of buffer-specific
   resources. This field is guaranteed to remain constant, while a consumer MAY
   pass a copy of the original buffer as the *view* argument.

   This function MUST NOT decrement *view->obj*, since that is done automatically
   in |:c-api/buffer.txt/c.PyBuffer_Release:PyBuffer_Release()| (this scheme is useful for breaking reference cycles).

   |:c-api/buffer.txt/c.PyBuffer_Release:PyBuffer_Release()| is the interface for the consumer that wraps this function.

*|async-structs:⚓|*  async-object-structures:Async Object Structures

New in version 3.5.

*c.PyAsyncMethods:type PyAsyncMethods
*

   This structure holds pointers to the functions required to implement |:glossary.txt/term-awaitable:awaitable|
   and |:glossary.txt/term-asynchronous-iterator:asynchronous iterator| objects.

   Here is the structure definition:

```rst
typedef struct {
    unaryfunc am_await;
    unaryfunc am_aiter;
    unaryfunc am_anext;
} PyAsyncMethods;
```

*c.PyAsyncMethods.am_await:|:c.unaryfunc:unaryfunc| |:c.PyAsyncMethods:PyAsyncMethods|.am_await
*

   The signature of this function is:

```rst
PyObject *am_await(PyObject *self);
```

   The returned object must be an iterator, i.e. |:c-api/iter.txt/c.PyIter_Check:PyIter_Check()| must return "1"
   for it.

   This slot may be set to "NULL" if an object is not an |:glossary.txt/term-awaitable:awaitable|.

*c.PyAsyncMethods.am_aiter:|:c.unaryfunc:unaryfunc| |:c.PyAsyncMethods:PyAsyncMethods|.am_aiter
*

   The signature of this function is:

```rst
PyObject *am_aiter(PyObject *self);
```

   Must return an |:glossary.txt/term-awaitable:awaitable| object.  See "__anext__()" for details.

   This slot may be set to "NULL" if an object does not implement asynchronous
   iteration protocol.

*c.PyAsyncMethods.am_anext:|:c.unaryfunc:unaryfunc| |:c.PyAsyncMethods:PyAsyncMethods|.am_anext
*

   The signature of this function is:

```rst
PyObject *am_anext(PyObject *self);
```

   Must return an |:glossary.txt/term-awaitable:awaitable| object.  See "__anext__()" for details. This slot may
   be set to "NULL".

*|id5:⚓|*  slot-type-typedefs:Slot Type typedefs

*c.allocfunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*allocfunc)(|:c-api/type.txt/c.PyTypeObject:PyTypeObject| *cls, Py_ssize_t nitems)
*

   The purpose of this function is to separate memory allocation from memory
   initialization.  It should return a pointer to a block of memory of adequate
   length for the instance, suitably aligned, and initialized to zeros, but with "
   ob_refcnt" set to "1" and "ob_type" set to the type argument.  If the type’s
   |:c.PyTypeObject.tp_itemsize:tp_itemsize| is non-zero, the object’s "ob_size" field should be initialized to
   *nitems* and the length of the allocated memory block should be "tp_basicsize +
   nitems*tp_itemsize", rounded up to a multiple of "sizeof(void*)"; otherwise, *
   nitems* is not used and the length of the block should be |:c.PyTypeObject.tp_basicsize:tp_basicsize|.

   This function should not do any other instance initialization, not even to
   allocate additional memory; that should be done by |:c.PyTypeObject.tp_new:tp_new|.

*c.destructor:typedef void (*destructor)(|:c-api/structures.txt/c.PyObject:PyObject|*)
*

*c.vectorcallfunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*vectorcallfunc)(|:c-api/structures.txt/c.PyObject:PyObject| *callable, |:c-api/structures.txt/c.PyObject:PyObject| *const *args, size_t nargsf, |:c-api/structures.txt/c.PyObject:PyObject| *kwnames)
*

   See |:c.PyTypeObject.tp_vectorcall_offset:tp_vectorcall_offset|.

   Arguments to "vectorcallfunc" are the same as for |:c-api/object.txt/c._PyObject_Vectorcall:_PyObject_Vectorcall()|.

   New in version 3.8.

*c.freefunc:typedef void (*freefunc)(void*)
*

   See |:c.PyTypeObject.tp_free:tp_free|.

*c.newfunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*newfunc)(|:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*)
*

   See |:c.PyTypeObject.tp_new:tp_new|.

*c.initproc:typedef int (*initproc)(|:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*)
*

   See |:c.PyTypeObject.tp_init:tp_init|.

*c.reprfunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*reprfunc)(|:c-api/structures.txt/c.PyObject:PyObject|*)
*

   See |:c.PyTypeObject.tp_repr:tp_repr|.

*c.getattrfunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*getattrfunc)(|:c-api/structures.txt/c.PyObject:PyObject| *self, char *attr)
*

   Return the value of the named attribute for the object.

*c.setattrfunc:typedef int (*setattrfunc)(|:c-api/structures.txt/c.PyObject:PyObject| *self, char *attr, |:c-api/structures.txt/c.PyObject:PyObject| *value)
*

   Set the value of the named attribute for the object. The value argument is set
   to "NULL" to delete the attribute.

*c.getattrofunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*getattrofunc)(|:c-api/structures.txt/c.PyObject:PyObject| *self, |:c-api/structures.txt/c.PyObject:PyObject| *attr)
*

   Return the value of the named attribute for the object.

   See |:c.PyTypeObject.tp_getattro:tp_getattro|.

*c.setattrofunc:typedef int (*setattrofunc)(|:c-api/structures.txt/c.PyObject:PyObject| *self, |:c-api/structures.txt/c.PyObject:PyObject| *attr, |:c-api/structures.txt/c.PyObject:PyObject| *value)
*

   Set the value of the named attribute for the object. The value argument is set
   to "NULL" to delete the attribute.

   See |:c.PyTypeObject.tp_setattro:tp_setattro|.

*c.descrgetfunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*descrgetfunc)(|:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*)
*

   See "tp_descrget".

*c.descrsetfunc:typedef int (*descrsetfunc)(|:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*)
*

   See "tp_descrset".

*c.hashfunc:typedef Py_hash_t (*hashfunc)(|:c-api/structures.txt/c.PyObject:PyObject|*)
*

   See |:c.PyTypeObject.tp_hash:tp_hash|.

*c.richcmpfunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*richcmpfunc)(|:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*, int)
*

   See |:c.PyTypeObject.tp_richcompare:tp_richcompare|.

*c.getiterfunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*getiterfunc)(|:c-api/structures.txt/c.PyObject:PyObject|*)
*

   See |:c.PyTypeObject.tp_iter:tp_iter|.

*c.iternextfunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*iternextfunc)(|:c-api/structures.txt/c.PyObject:PyObject|*)
*

   See |:c.PyTypeObject.tp_iternext:tp_iternext|.

*c.lenfunc:typedef Py_ssize_t (*lenfunc)(|:c-api/structures.txt/c.PyObject:PyObject|*)
*

*c.getbufferproc:typedef int (*getbufferproc)(|:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/buffer.txt/c.Py_buffer:Py_buffer|*, int)
*

*c.releasebufferproc:typedef void (*releasebufferproc)(|:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/buffer.txt/c.Py_buffer:Py_buffer|*)
*

*c.unaryfunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*unaryfunc)(|:c-api/structures.txt/c.PyObject:PyObject|*)
*

*c.binaryfunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*binaryfunc)(|:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*)
*

*c.ternaryfunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*ternaryfunc)(|:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*)
*

*c.ssizeargfunc:typedef |:c-api/structures.txt/c.PyObject:PyObject| *(*ssizeargfunc)(|:c-api/structures.txt/c.PyObject:PyObject|*, Py_ssize_t)
*

*c.ssizeobjargproc:typedef int (*ssizeobjargproc)(|:c-api/structures.txt/c.PyObject:PyObject|*, Py_ssize_t)
*

*c.objobjproc:typedef int (*objobjproc)(|:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*)
*

*c.objobjargproc:typedef int (*objobjargproc)(|:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*, |:c-api/structures.txt/c.PyObject:PyObject|*)
*

*|typedef-examples:⚓|*  examples:Examples

The following are simple examples of Python type definitions.  They include
common usage you may encounter.  Some demonstrate tricky corner cases.  For more
examples, practical info, and a tutorial, see
|:extending/newtypes_tutorial.txt/defining-new-types:Defining Extension Types: Tutorial| and
|:extending/newtypes.txt/new-types-topics:Defining Extension Types: Assorted Topics|.

A basic static type:

```rst
typedef struct {
    PyObject_HEAD
    const char *data;
} MyObject;

static PyTypeObject MyObject_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "mymod.MyObject",
    .tp_basicsize = sizeof(MyObject),
    .tp_doc = "My objects",
    .tp_new = myobj_new,
    .tp_dealloc = (destructor)myobj_dealloc,
    .tp_repr = (reprfunc)myobj_repr,
};
```

You may also find older code (especially in the CPython code base) with a more
verbose initializer:

```rst
static PyTypeObject MyObject_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "mymod.MyObject",               /* tp_name */
    sizeof(MyObject),               /* tp_basicsize */
    0,                              /* tp_itemsize */
    (destructor)myobj_dealloc,      /* tp_dealloc */
    0,                              /* tp_vectorcall_offset */
    0,                              /* tp_getattr */
    0,                              /* tp_setattr */
    0,                              /* tp_as_async */
    (reprfunc)myobj_repr,           /* tp_repr */
    0,                              /* tp_as_number */
    0,                              /* tp_as_sequence */
    0,                              /* tp_as_mapping */
    0,                              /* tp_hash */
    0,                              /* tp_call */
    0,                              /* tp_str */
    0,                              /* tp_getattro */
    0,                              /* tp_setattro */
    0,                              /* tp_as_buffer */
    0,                              /* tp_flags */
    "My objects",                   /* tp_doc */
    0,                              /* tp_traverse */
    0,                              /* tp_clear */
    0,                              /* tp_richcompare */
    0,                              /* tp_weaklistoffset */
    0,                              /* tp_iter */
    0,                              /* tp_iternext */
    0,                              /* tp_methods */
    0,                              /* tp_members */
    0,                              /* tp_getset */
    0,                              /* tp_base */
    0,                              /* tp_dict */
    0,                              /* tp_descr_get */
    0,                              /* tp_descr_set */
    0,                              /* tp_dictoffset */
    0,                              /* tp_init */
    0,                              /* tp_alloc */
    myobj_new,                      /* tp_new */
};
```

A type that supports weakrefs, instance dicts, and hashing:

```rst
typedef struct {
    PyObject_HEAD
    const char *data;
    PyObject *inst_dict;
    PyObject *weakreflist;
} MyObject;

static PyTypeObject MyObject_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "mymod.MyObject",
    .tp_basicsize = sizeof(MyObject),
    .tp_doc = "My objects",
    .tp_weaklistoffset = offsetof(MyObject, weakreflist),
    .tp_dictoffset = offsetof(MyObject, inst_dict),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
    .tp_new = myobj_new,
    .tp_traverse = (traverseproc)myobj_traverse,
    .tp_clear = (inquiry)myobj_clear,
    .tp_alloc = PyType_GenericNew,
    .tp_dealloc = (destructor)myobj_dealloc,
    .tp_repr = (reprfunc)myobj_repr,
    .tp_hash = (hashfunc)myobj_hash,
    .tp_richcompare = PyBaseObject_Type.tp_richcompare,
};
```

A str subclass that cannot be subclassed and cannot be called to create
instances (e.g. uses a separate factory func):

```rst
typedef struct {
    PyUnicodeObject raw;
    char *extra;
} MyStr;

static PyTypeObject MyStr_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "mymod.MyStr",
    .tp_basicsize = sizeof(MyStr),
    .tp_base = NULL,  // set to &PyUnicode_Type in module init
    .tp_doc = "my custom str",
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_new = NULL,
    .tp_repr = (reprfunc)myobj_repr,
};
```

The simplest static type (with fixed-length instances):

```rst
typedef struct {
    PyObject_HEAD
} MyObject;

static PyTypeObject MyObject_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "mymod.MyObject",
};
```

The simplest static type (with variable-length instances):

```rst
typedef struct {
    PyObject_VAR_HEAD
    const char *data[1];
} MyObject;

static PyTypeObject MyObject_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "mymod.MyObject",
    .tp_basicsize = sizeof(MyObject) - sizeof(char *),
    .tp_itemsize = sizeof(char *),
};
```



