%hyperhelp title="sqlite3" date="2021-07-11"
*|module-sqlite3:⚓|*

*Source code:* |:github.com/python/cpython/tree/3.8/Lib/sqlite3:Lib/sqlite3/|

======================================================================

SQLite is a C library that provides a lightweight disk-based database that
doesn’t require a separate server process and allows accessing the database
using a nonstandard variant of the SQL query language. Some applications can use
SQLite for internal data storage.  It’s also possible to prototype an
application using SQLite and then port the code to a larger database such as
PostgreSQL or Oracle.

The sqlite3 module was written by Gerhard Häring.  It provides a SQL interface
compliant with the DB-API 2.0 specification described by *|index-0:⚓|* |:www.python.org/dev/peps/pep-0249:PEP 249|
.

To use the module, you must first create a |:sqlite3.Connection:Connection| object that represents
the database.  Here the data will be stored in the "example.db" file:

```rst
import sqlite3
conn = sqlite3.connect('example.db')
```

You can also supply the special name ":memory:" to create a database in RAM.

Once you have a |:sqlite3.Connection:Connection|, you can create a |:sqlite3.Cursor:Cursor|  object and call its
|:sqlite3.Cursor.execute:execute()| method to perform SQL commands:

```rst
c = conn.cursor()

# Create table
c.execute('''CREATE TABLE stocks
             (date text, trans text, symbol text, qty real, price real)''')

# Insert a row of data
c.execute("INSERT INTO stocks VALUES ('2006-01-05','BUY','RHAT',100,35.14)")

# Save (commit) the changes
conn.commit()

# We can also close the connection if we are done with it.
# Just be sure any changes have been committed or they will be lost.
conn.close()
```

The data you’ve saved is persistent and is available in subsequent sessions:

```rst
import sqlite3
conn = sqlite3.connect('example.db')
c = conn.cursor()
```

Usually your SQL operations will need to use values from Python variables.  You
shouldn’t assemble your query using Python’s string operations because doing so
is insecure; it makes your program vulnerable to an SQL injection attack (see
|:xkcd.com/327:https://xkcd.com/327/| for humorous example of what can go wrong).

Instead, use the DB-API’s parameter substitution.  Put "?" as a placeholder
wherever you want to use a value, and then provide a tuple of values as the
second argument to the cursor’s |:sqlite3.Cursor.execute:execute()| method.  (Other database modules may
use a different placeholder, such as "%s" or ":1".) For example:

```rst
# Never do this -- insecure!
symbol = 'RHAT'
c.execute("SELECT * FROM stocks WHERE symbol = '%s'" % symbol)

# Do this instead
t = ('RHAT',)
c.execute('SELECT * FROM stocks WHERE symbol=?', t)
print(c.fetchone())

# Larger example that inserts many records at a time
purchases = [('2006-03-28', 'BUY', 'IBM', 1000, 45.00),
             ('2006-04-05', 'BUY', 'MSFT', 1000, 72.00),
             ('2006-04-06', 'SELL', 'IBM', 500, 53.00),
            ]
c.executemany('INSERT INTO stocks VALUES (?,?,?,?,?)', purchases)
```

To retrieve data after executing a SELECT statement, you can either treat the
cursor as an |:glossary.txt/term-iterator:iterator|, call the cursor’s |:sqlite3.Cursor.fetchone:fetchone()| method to retrieve a
single matching row, or call |:sqlite3.Cursor.fetchall:fetchall()| to get a list of the matching rows.

This example uses the iterator form:

```rst
>>> for row in c.execute('SELECT * FROM stocks ORDER BY price'):
        print(row)

('2006-01-05', 'BUY', 'RHAT', 100, 35.14)
('2006-03-28', 'BUY', 'IBM', 1000, 45.0)
('2006-04-06', 'SELL', 'IBM', 500, 53.0)
('2006-04-05', 'BUY', 'MSFT', 1000, 72.0)
```

See also:

  |:www.sqlite.org:https://www.sqlite.org|
     The SQLite web page; the documentation describes the syntax and the available
     data types for the supported SQL dialect.

  |:www.w3schools.com/sql:https://www.w3schools.com/sql/|
     Tutorial, reference and examples for learning SQL syntax.

  *|index-1:⚓|*
  |:www.python.org/dev/peps/pep-0249:PEP 249| - Database API Specification 2.0
     PEP written by Marc-André Lemburg.

# module-functions-and-constants:Module functions and constants

*sqlite3.version:sqlite3.version*

   The version number of this module, as a string. This is not the version of the
   SQLite library.

*sqlite3.version_info:sqlite3.version_info*

   The version number of this module, as a tuple of integers. This is not the
   version of the SQLite library.

*sqlite3.sqlite_version:sqlite3.sqlite_version*

   The version number of the run-time SQLite library, as a string.

*sqlite3.sqlite_version_info:sqlite3.sqlite_version_info*

   The version number of the run-time SQLite library, as a tuple of integers.

*sqlite3.PARSE_DECLTYPES:sqlite3.PARSE_DECLTYPES*

   This constant is meant to be used with the *detect_types* parameter of the
   |:sqlite3.connect:connect()| function.

   Setting it makes the |:module-sqlite3:sqlite3| module parse the declared type for each column it
   returns.  It will parse out the first word of the declared type, i. e.  for
   “integer primary key”, it will parse out “integer”, or for “number(10)” it will
   parse out “number”. Then for that column, it will look into the converters
   dictionary and use the converter function registered for that type there.

*sqlite3.PARSE_COLNAMES:sqlite3.PARSE_COLNAMES*

   This constant is meant to be used with the *detect_types* parameter of the
   |:sqlite3.connect:connect()| function.

   Setting this makes the SQLite interface parse the column name for each column it
   returns.  It will look for a string formed [mytype] in there, and then decide
   that ‘mytype’ is the type of the column. It will try to find an entry of
   ‘mytype’ in the converters dictionary and then use the converter function found
   there to return the value. The column name found in |:sqlite3.Cursor.description:Cursor.description| does
   not include the type, i. e. if you use something like "'as "Expiration date
   [datetime]"'" in your SQL, then we will parse out everything until the first "
   '['" for the column name and strip the preceeding space: the column name would
   simply be “Expiration date”.

*sqlite3.connect:sqlite3.connect(database[, timeout, detect_types, isolation_level, check_same_thread, factory, cached_statements, uri])*

   Opens a connection to the SQLite database file *database*. By default returns a
   |:sqlite3.Connection:Connection| object, unless a custom *factory* is given.

   *database* is a |:glossary.txt/term-path-like-object:path-like object| giving the pathname (absolute or relative to
   the current  working directory) of the database file to be opened. You can use "
   ":memory:"" to open a database connection to a database that resides in RAM
   instead of on disk.

   When a database is accessed by multiple connections, and one of the processes
   modifies the database, the SQLite database is locked until that transaction is
   committed. The *timeout* parameter specifies how long the connection should wait
   for the lock to go away until raising an exception. The default for the timeout
   parameter is 5.0 (five seconds).

   For the *isolation_level* parameter, please see the |:sqlite3.Connection.isolation_level:isolation_level| property
   of |:sqlite3.Connection:Connection| objects.

   SQLite natively supports only the types TEXT, INTEGER, REAL, BLOB and NULL. If
   you want to use other types you must add support for them yourself. The *
   detect_types* parameter and the using custom *converters* registered with the
   module-level |:sqlite3.register_converter:register_converter()| function allow you to easily do that.

   *detect_types* defaults to 0 (i. e. off, no type detection), you can set it to
   any combination of |:sqlite3.PARSE_DECLTYPES:PARSE_DECLTYPES| and |:sqlite3.PARSE_COLNAMES:PARSE_COLNAMES| to turn type detection
   on. Due to SQLite behaviour, types can’t be detected for generated fields (for
   example "max(data)"), even when *detect_types* parameter is set. In such case,
   the returned type is |:library/stdtypes.txt/str:str|.

   By default, *check_same_thread* is |:library/constants.txt/True:True| and only the creating thread may use
   the connection. If set |:library/constants.txt/False:False|, the returned connection may be shared across
   multiple threads. When using multiple threads with the same connection writing
   operations should be serialized by the user to avoid data corruption.

   By default, the |:module-sqlite3:sqlite3| module uses its |:sqlite3.Connection:Connection| class for the connect
   call.  You can, however, subclass the |:sqlite3.Connection:Connection| class and make |:sqlite3.connect:connect()|
   use your class instead by providing your class for the *factory* parameter.

   Consult the section |:sqlite3-types:SQLite and Python types| of this manual for details.

   The |:module-sqlite3:sqlite3| module internally uses a statement cache to avoid SQL parsing
   overhead. If you want to explicitly set the number of statements that are cached
   for the connection, you can set the *cached_statements* parameter. The currently
   implemented default is to cache 100 statements.

   If *uri* is true, *database* is interpreted as a URI. This allows you to specify
   options. For example, to open a database in read-only mode you can use:

```rst
db = sqlite3.connect('file:path/to/database?mode=ro', uri=True)
```

   More information about this feature, including a list of recognized options, can
   be found in the |:www.sqlite.org/uri.html:SQLite URI documentation|*|sqlite-uri-documentation:⚓|* .

   Raises an |:library/sys.txt/auditing:auditing event| "sqlite3.connect" with argument "database".

   Changed in version 3.4: Added the *uri* parameter.

   Changed in version 3.7: *database* can now also be a |:glossary.txt/term-path-like-object:path-like object|, not
   only a string.

*sqlite3.register_converter:sqlite3.register_converter(typename, callable)*

   Registers a callable to convert a bytestring from the database into a custom
   Python type. The callable will be invoked for all database values that are of
   the type *typename*. Confer the parameter *detect_types* of the |:sqlite3.connect:connect()|
   function for how the type detection works. Note that *typename* and the name of
   the type in your query are matched in case-insensitive manner.

*sqlite3.register_adapter:sqlite3.register_adapter(type, callable)*

   Registers a callable to convert the custom Python type *type* into one of
   SQLite’s supported types. The callable *callable* accepts as single parameter
   the Python value, and must return a value of the following types: int, float,
   str or bytes.

*sqlite3.complete_statement:sqlite3.complete_statement(sql)*

   Returns |:library/constants.txt/True:True| if the string *sql* contains one or more complete SQL statements
   terminated by semicolons. It does not verify that the SQL is syntactically
   correct, only that there are no unclosed string literals and the statement is
   terminated by a semicolon.

   This can be used to build a shell for SQLite, as in the following example:

```rst
# A minimal SQLite shell for experiments

import sqlite3

con = sqlite3.connect(":memory:")
con.isolation_level = None
cur = con.cursor()

buffer = ""

print("Enter your SQL commands to execute in sqlite3.")
print("Enter a blank line to exit.")

while True:
    line = input()
    if line == "":
        break
    buffer += line
    if sqlite3.complete_statement(buffer):
        try:
            buffer = buffer.strip()
            cur.execute(buffer)

            if buffer.lstrip().upper().startswith("SELECT"):
                print(cur.fetchall())
        except sqlite3.Error as e:
            print("An error occurred:", e.args[0])
        buffer = ""

con.close()

```

*sqlite3.enable_callback_tracebacks:sqlite3.enable_callback_tracebacks(flag)*

   By default you will not get any tracebacks in user-defined functions,
   aggregates, converters, authorizer callbacks etc. If you want to debug them, you
   can call this function with *flag* set to "True". Afterwards, you will get
   tracebacks from callbacks on "sys.stderr". Use |:library/constants.txt/False:False| to disable the feature
   again.

*|sqlite3-connection-objects:⚓|* # connection-objects:Connection Objects

*sqlite3.Connection:class sqlite3.Connection*

   A SQLite database connection has the following attributes and methods:

   *sqlite3.Connection.isolation_level:isolation_level*

      Get or set the current default isolation level. |:library/constants.txt/None:None| for autocommit mode or
      one of “DEFERRED”, “IMMEDIATE” or “EXCLUSIVE”. See section
      |:sqlite3-controlling-transactions:Controlling Transactions| for a more detailed explanation.

   *sqlite3.Connection.in_transaction:in_transaction*

      |:library/constants.txt/True:True| if a transaction is active (there are uncommitted changes), |:library/constants.txt/False:False|
      otherwise.  Read-only attribute.

      New in version 3.2.

   *sqlite3.Connection.cursor:cursor(factory=Cursor)*

      The cursor method accepts a single optional parameter *factory*. If supplied,
      this must be a callable returning an instance of |:sqlite3.Cursor:Cursor| or its subclasses.

   *sqlite3.Connection.commit:commit()*

      This method commits the current transaction. If you don’t call this method,
      anything you did since the last call to "commit()" is not visible from other
      database connections. If you wonder why you don’t see the data you’ve written to
      the database, please check you didn’t forget to call this method.

   *sqlite3.Connection.rollback:rollback()*

      This method rolls back any changes to the database since the last call to
      |:sqlite3.Connection.commit:commit()|.

   *sqlite3.Connection.close:close()*

      This closes the database connection. Note that this does not automatically call
      |:sqlite3.Connection.commit:commit()|. If you just close your database connection without calling
      |:sqlite3.Connection.commit:commit()| first, your changes will be lost!

   *sqlite3.Connection.execute:execute(sql[, parameters])*

      This is a nonstandard shortcut that creates a cursor object by calling the
      |:sqlite3.Connection.cursor:cursor()| method, calls the cursor’s |:sqlite3.Cursor.execute:execute()| method with the *parameters*
      given, and returns the cursor.

   *sqlite3.Connection.executemany:executemany(sql[, parameters])*

      This is a nonstandard shortcut that creates a cursor object by calling the
      |:sqlite3.Connection.cursor:cursor()| method, calls the cursor’s |:sqlite3.Cursor.executemany:executemany()| method with the *
      parameters* given, and returns the cursor.

   *sqlite3.Connection.executescript:executescript(sql_script)*

      This is a nonstandard shortcut that creates a cursor object by calling the
      |:sqlite3.Connection.cursor:cursor()| method, calls the cursor’s |:sqlite3.Cursor.executescript:executescript()| method with the given *
      sql_script*, and returns the cursor.

   *sqlite3.Connection.create_function:create_function(name, num_params, func, *, deterministic=False)*

      Creates a user-defined function that you can later use from within SQL
      statements under the function name *name*. *num_params* is the number of
      parameters the function accepts (if *num_params* is -1, the function may take
      any number of arguments), and *func* is a Python callable that is called as the
      SQL function. If *deterministic* is true, the created function is marked as
      |:sqlite.org/deterministic.html:deterministic|*|deterministic:⚓|* , which allows SQLite to perform additional
      optimizations. This flag is supported by SQLite 3.8.3 or higher,
      |:sqlite3.NotSupportedError:NotSupportedError| will be raised if used with older versions.

      The function can return any of the types supported by SQLite: bytes, str, int,
      float and "None".

      Changed in version 3.8: The *deterministic* parameter was added.

      Example:

```rst
import sqlite3
import hashlib

def md5sum(t):
    return hashlib.md5(t).hexdigest()

con = sqlite3.connect(":memory:")
con.create_function("md5", 1, md5sum)
cur = con.cursor()
cur.execute("select md5(?)", (b"foo",))
print(cur.fetchone()[0])

con.close()

```

   *sqlite3.Connection.create_aggregate:create_aggregate(name, num_params, aggregate_class)*

      Creates a user-defined aggregate function.

      The aggregate class must implement a "step" method, which accepts the number of
      parameters *num_params* (if *num_params* is -1, the function may take any number
      of arguments), and a "finalize" method which will return the final result of the
      aggregate.

      The "finalize" method can return any of the types supported by SQLite: bytes,
      str, int, float and "None".

      Example:

```rst
import sqlite3

class MySum:
    def __init__(self):
        self.count = 0

    def step(self, value):
        self.count += value

    def finalize(self):
        return self.count

con = sqlite3.connect(":memory:")
con.create_aggregate("mysum", 1, MySum)
cur = con.cursor()
cur.execute("create table test(i)")
cur.execute("insert into test(i) values (1)")
cur.execute("insert into test(i) values (2)")
cur.execute("select mysum(i) from test")
print(cur.fetchone()[0])

con.close()

```

   *sqlite3.Connection.create_collation:create_collation(name, callable)*

      Creates a collation with the specified *name* and *callable*. The callable will
      be passed two string arguments. It should return -1 if the first is ordered
      lower than the second, 0 if they are ordered equal and 1 if the first is ordered
      higher than the second.  Note that this controls sorting (ORDER BY in SQL) so
      your comparisons don’t affect other SQL operations.

      Note that the callable will get its parameters as Python bytestrings, which will
      normally be encoded in UTF-8.

      The following example shows a custom collation that sorts “the wrong way”:

```rst
import sqlite3

def collate_reverse(string1, string2):
    if string1 == string2:
        return 0
    elif string1 < string2:
        return 1
    else:
        return -1

con = sqlite3.connect(":memory:")
con.create_collation("reverse", collate_reverse)

cur = con.cursor()
cur.execute("create table test(x)")
cur.executemany("insert into test(x) values (?)", [("a",), ("b",)])
cur.execute("select x from test order by x collate reverse")
for row in cur:
    print(row)
con.close()

```

      To remove a collation, call "create_collation" with "None" as callable:

```rst
con.create_collation("reverse", None)
```

   *sqlite3.Connection.interrupt:interrupt()*

      You can call this method from a different thread to abort any queries that might
      be executing on the connection. The query will then abort and the caller will
      get an exception.

   *sqlite3.Connection.set_authorizer:set_authorizer(authorizer_callback)*

      This routine registers a callback. The callback is invoked for each attempt to
      access a column of a table in the database. The callback should return "
      SQLITE_OK" if access is allowed, "SQLITE_DENY" if the entire SQL statement
      should be aborted with an error and "SQLITE_IGNORE" if the column should be
      treated as a NULL value. These constants are available in the |:module-sqlite3:sqlite3| module.

      The first argument to the callback signifies what kind of operation is to be
      authorized. The second and third argument will be arguments or |:library/constants.txt/None:None| depending
      on the first argument. The 4th argument is the name of the database (“main”,
      “temp”, etc.) if applicable. The 5th argument is the name of the inner-most
      trigger or view that is responsible for the access attempt or |:library/constants.txt/None:None| if this
      access attempt is directly from input SQL code.

      Please consult the SQLite documentation about the possible values for the first
      argument and the meaning of the second and third argument depending on the first
      one. All necessary constants are available in the |:module-sqlite3:sqlite3| module.

   *sqlite3.Connection.set_progress_handler:set_progress_handler(handler, n)*

      This routine registers a callback. The callback is invoked for every *n*
      instructions of the SQLite virtual machine. This is useful if you want to get
      called from SQLite during long-running operations, for example to update a GUI.

      If you want to clear any previously installed progress handler, call the method
      with |:library/constants.txt/None:None| for *handler*.

      Returning a non-zero value from the handler function will terminate the
      currently executing query and cause it to raise an |:sqlite3.OperationalError:OperationalError| exception.

   *sqlite3.Connection.set_trace_callback:set_trace_callback(trace_callback)*

      Registers *trace_callback* to be called for each SQL statement that is actually
      executed by the SQLite backend.

      The only argument passed to the callback is the statement (as string) that is
      being executed. The return value of the callback is ignored. Note that the
      backend does not only run statements passed to the |:sqlite3.Cursor.execute:Cursor.execute()| methods.
      Other sources include the transaction management of the Python module and the
      execution of triggers defined in the current database.

      Passing |:library/constants.txt/None:None| as *trace_callback* will disable the trace callback.

      New in version 3.3.

   *sqlite3.Connection.enable_load_extension:enable_load_extension(enabled)*

      This routine allows/disallows the SQLite engine to load SQLite extensions from
      shared libraries.  SQLite extensions can define new functions, aggregates or
      whole new virtual table implementations.  One well-known extension is the
      fulltext-search extension distributed with SQLite.

      Loadable extensions are disabled by default. See [1].

      New in version 3.2.

```rst
import sqlite3

con = sqlite3.connect(":memory:")

# enable extension loading
con.enable_load_extension(True)

# Load the fulltext search extension
con.execute("select load_extension('./fts3.so')")

# alternatively you can load the extension using an API call:
# con.load_extension("./fts3.so")

# disable extension loading again
con.enable_load_extension(False)

# example from SQLite wiki
con.execute("create virtual table recipe using fts3(name, ingredients)")
con.executescript("""
    insert into recipe (name, ingredients) values ('broccoli stew', 'broccoli peppers cheese tomatoes');
    insert into recipe (name, ingredients) values ('pumpkin stew', 'pumpkin onions garlic celery');
    insert into recipe (name, ingredients) values ('broccoli pie', 'broccoli cheese onions flour');
    insert into recipe (name, ingredients) values ('pumpkin pie', 'pumpkin sugar flour butter');
    """)
for row in con.execute("select rowid, name, ingredients from recipe where name match 'pie'"):
    print(row)

con.close()

```

   *sqlite3.Connection.load_extension:load_extension(path)*

      This routine loads a SQLite extension from a shared library.  You have to enable
      extension loading with |:sqlite3.Connection.enable_load_extension:enable_load_extension()| before you can use this
      routine.

      Loadable extensions are disabled by default. See [1].

      New in version 3.2.

   *sqlite3.Connection.row_factory:row_factory*

      You can change this attribute to a callable that accepts the cursor and the
      original row as a tuple and will return the real result row.  This way, you can
      implement more advanced ways of returning results, such  as returning an object
      that can also access columns by name.

      Example:

```rst
import sqlite3

def dict_factory(cursor, row):
    d = {}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d

con = sqlite3.connect(":memory:")
con.row_factory = dict_factory
cur = con.cursor()
cur.execute("select 1 as a")
print(cur.fetchone()["a"])

con.close()

```

      If returning a tuple doesn’t suffice and you want name-based access to columns,
      you should consider setting |:sqlite3.Connection.row_factory:row_factory| to the highly-optimized |:sqlite3.Row:sqlite3.Row|
      type. |:sqlite3.Row:Row| provides both index-based and case-insensitive name-based access to
      columns with almost no memory overhead. It will probably be better than your own
      custom dictionary-based approach or even a db_row based solution.

   *sqlite3.Connection.text_factory:text_factory*

      Using this attribute you can control what objects are returned for the "TEXT"
      data type. By default, this attribute is set to |:library/stdtypes.txt/str:str| and the |:module-sqlite3:sqlite3| module
      will return Unicode objects for "TEXT". If you want to return bytestrings
      instead, you can set it to |:library/stdtypes.txt/bytes:bytes|.

      You can also set it to any other callable that accepts a single bytestring
      parameter and returns the resulting object.

      See the following example code for illustration:

```rst
import sqlite3

con = sqlite3.connect(":memory:")
cur = con.cursor()

AUSTRIA = "\xd6sterreich"

# by default, rows are returned as Unicode
cur.execute("select ?", (AUSTRIA,))
row = cur.fetchone()
assert row[0] == AUSTRIA

# but we can make sqlite3 always return bytestrings ...
con.text_factory = bytes
cur.execute("select ?", (AUSTRIA,))
row = cur.fetchone()
assert type(row[0]) is bytes
# the bytestrings will be encoded in UTF-8, unless you stored garbage in the
# database ...
assert row[0] == AUSTRIA.encode("utf-8")

# we can also implement a custom text_factory ...
# here we implement one that appends "foo" to all strings
con.text_factory = lambda x: x.decode("utf-8") + "foo"
cur.execute("select ?", ("bar",))
row = cur.fetchone()
assert row[0] == "barfoo"

con.close()

```

   *sqlite3.Connection.total_changes:total_changes*

      Returns the total number of database rows that have been modified, inserted, or
      deleted since the database connection was opened.

   *sqlite3.Connection.iterdump:iterdump()*

      Returns an iterator to dump the database in an SQL text format.  Useful when
      saving an in-memory database for later restoration.  This function provides the
      same capabilities as the ".dump" command in the *sqlite3* shell.

      Example:

```rst
# Convert file existing_db.db to SQL dump file dump.sql
import sqlite3

con = sqlite3.connect('existing_db.db')
with open('dump.sql', 'w') as f:
    for line in con.iterdump():
        f.write('%s\n' % line)
con.close()
```

   *sqlite3.Connection.backup:backup(target, *, pages=- 1, progress=None, name='main', sleep=0.250)*

      This method makes a backup of a SQLite database even while it’s being accessed
      by other clients, or concurrently by the same connection.  The copy will be
      written into the mandatory argument *target*, that must be another |:sqlite3.Connection:Connection|
      instance.

      By default, or when *pages* is either "0" or a negative integer, the entire
      database is copied in a single step; otherwise the method performs a loop
      copying up to *pages* pages at a time.

      If *progress* is specified, it must either be "None" or a callable object that
      will be executed at each iteration with three integer arguments, respectively
      the *status* of the last iteration, the *remaining* number of pages still to be
      copied and the *total* number of pages.

      The *name* argument specifies the database name that will be copied: it must be
      a string containing either ""main"", the default, to indicate the main database,
      ""temp"" to indicate the temporary database or the name specified after the "AS"
      keyword in an "ATTACH DATABASE" statement for an attached database.

      The *sleep* argument specifies the number of seconds to sleep by between
      successive attempts to backup remaining pages, can be specified either as an
      integer or a floating point value.

      Example 1, copy an existing database into another:

```rst
import sqlite3

def progress(status, remaining, total):
    print(f'Copied {total-remaining} of {total} pages...')

con = sqlite3.connect('existing_db.db')
bck = sqlite3.connect('backup.db')
with bck:
    con.backup(bck, pages=1, progress=progress)
bck.close()
con.close()
```

      Example 2, copy an existing database into a transient copy:

```rst
import sqlite3

source = sqlite3.connect('existing_db.db')
dest = sqlite3.connect(':memory:')
source.backup(dest)
```

      Availability: SQLite 3.6.11 or higher

      New in version 3.7.

*|sqlite3-cursor-objects:⚓|* # cursor-objects:Cursor Objects

*sqlite3.Cursor:class sqlite3.Cursor*

   A |:sqlite3.Cursor:Cursor| instance has the following attributes and methods.

   *|index-2:⚓|* *|index-3:⚓|*

   *sqlite3.Cursor.execute:execute(sql[, parameters])*

      Executes an SQL statement. The SQL statement may be parameterized (i. e.
      placeholders instead of SQL literals). The |:module-sqlite3:sqlite3| module supports two kinds
      of placeholders: question marks (qmark style) and named placeholders (named
      style).

      Here’s an example of both styles:

```rst
import sqlite3

con = sqlite3.connect(":memory:")
cur = con.cursor()
cur.execute("create table people (name_last, age)")

who = "Yeltsin"
age = 72

# This is the qmark style:
cur.execute("insert into people values (?, ?)", (who, age))

# And this is the named style:
cur.execute("select * from people where name_last=:who and age=:age", {"who": who, "age": age})

print(cur.fetchone())

con.close()

```

      |:sqlite3.Cursor.execute:execute()| will only execute a single SQL statement. If you try to execute more
      than one statement with it, it will raise a |:sqlite3.Warning:Warning|. Use |:sqlite3.Cursor.executescript:executescript()| if
      you want to execute multiple SQL statements with one call.

   *sqlite3.Cursor.executemany:executemany(sql, seq_of_parameters)*

      Executes an SQL command against all parameter sequences or mappings found in the
      sequence *seq_of_parameters*.  The |:module-sqlite3:sqlite3| module also allows using an
      |:glossary.txt/term-iterator:iterator| yielding parameters instead of a sequence.

```rst
import sqlite3

class IterChars:
    def __init__(self):
        self.count = ord('a')

    def __iter__(self):
        return self

    def __next__(self):
        if self.count > ord('z'):
            raise StopIteration
        self.count += 1
        return (chr(self.count - 1),) # this is a 1-tuple

con = sqlite3.connect(":memory:")
cur = con.cursor()
cur.execute("create table characters(c)")

theIter = IterChars()
cur.executemany("insert into characters(c) values (?)", theIter)

cur.execute("select c from characters")
print(cur.fetchall())

con.close()

```

      Here’s a shorter example using a |:glossary.txt/term-generator:generator|:

```rst
import sqlite3
import string

def char_generator():
    for c in string.ascii_lowercase:
        yield (c,)

con = sqlite3.connect(":memory:")
cur = con.cursor()
cur.execute("create table characters(c)")

cur.executemany("insert into characters(c) values (?)", char_generator())

cur.execute("select c from characters")
print(cur.fetchall())

con.close()

```

   *sqlite3.Cursor.executescript:executescript(sql_script)*

      This is a nonstandard convenience method for executing multiple SQL statements
      at once. It issues a "COMMIT" statement first, then executes the SQL script it
      gets as a parameter.

      *sql_script* can be an instance of |:library/stdtypes.txt/str:str|.

      Example:

```rst
import sqlite3

con = sqlite3.connect(":memory:")
cur = con.cursor()
cur.executescript("""
    create table person(
        firstname,
        lastname,
        age
    );

    create table book(
        title,
        author,
        published
    );

    insert into book(title, author, published)
    values (
        'Dirk Gently''s Holistic Detective Agency',
        'Douglas Adams',
        1987
    );
    """)
con.close()

```

   *sqlite3.Cursor.fetchone:fetchone()*

      Fetches the next row of a query result set, returning a single sequence, or
      |:library/constants.txt/None:None| when no more data is available.

   *sqlite3.Cursor.fetchmany:fetchmany(size=cursor.arraysize)*

      Fetches the next set of rows of a query result, returning a list.  An empty list
      is returned when no more rows are available.

      The number of rows to fetch per call is specified by the *size* parameter. If it
      is not given, the cursor’s arraysize determines the number of rows to be
      fetched. The method should try to fetch as many rows as indicated by the size
      parameter. If this is not possible due to the specified number of rows not being
      available, fewer rows may be returned.

      Note there are performance considerations involved with the *size* parameter.
      For optimal performance, it is usually best to use the arraysize attribute. If
      the *size* parameter is used, then it is best for it to retain the same value
      from one |:sqlite3.Cursor.fetchmany:fetchmany()| call to the next.

   *sqlite3.Cursor.fetchall:fetchall()*

      Fetches all (remaining) rows of a query result, returning a list.  Note that the
      cursor’s arraysize attribute can affect the performance of this operation. An
      empty list is returned when no rows are available.

   *sqlite3.Cursor.close:close()*

      Close the cursor now (rather than whenever "__del__" is called).

      The cursor will be unusable from this point forward; a |:sqlite3.ProgrammingError:ProgrammingError|
      exception will be raised if any operation is attempted with the cursor.

   *sqlite3.Cursor.rowcount:rowcount*

      Although the |:sqlite3.Cursor:Cursor| class of the |:module-sqlite3:sqlite3| module implements this attribute,
      the database engine’s own support for the determination of “rows affected”/”rows
      selected” is quirky.

      For |:sqlite3.Cursor.executemany:executemany()| statements, the number of modifications are summed up into
      |:sqlite3.Cursor.rowcount:rowcount|.

      As required by the Python DB API Spec, the |:sqlite3.Cursor.rowcount:rowcount| attribute “is -1 in case
      no "executeXX()" has been performed on the cursor or the rowcount of the last
      operation is not determinable by the interface”. This includes "SELECT"
      statements because we cannot determine the number of rows a query produced until
      all rows were fetched.

      With SQLite versions before 3.6.5, |:sqlite3.Cursor.rowcount:rowcount| is set to 0 if you make a "DELETE
      FROM table" without any condition.

   *sqlite3.Cursor.lastrowid:lastrowid*

      This read-only attribute provides the rowid of the last modified row. It is only
      set if you issued an "INSERT" or a "REPLACE" statement using the |:sqlite3.Cursor.execute:execute()|
      method.  For operations other than "INSERT" or "REPLACE" or when |:sqlite3.Cursor.executemany:executemany()|
      is called, |:sqlite3.Cursor.lastrowid:lastrowid| is set to |:library/constants.txt/None:None|.

      If the "INSERT" or "REPLACE" statement failed to insert the previous successful
      rowid is returned.

      Changed in version 3.6: Added support for the "REPLACE" statement.

   *sqlite3.Cursor.arraysize:arraysize*

      Read/write attribute that controls the number of rows returned by |:sqlite3.Cursor.fetchmany:fetchmany()|.
      The default value is 1 which means a single row would be fetched per call.

   *sqlite3.Cursor.description:description*

      This read-only attribute provides the column names of the last query. To remain
      compatible with the Python DB API, it returns a 7-tuple for each column where
      the last six items of each tuple are |:library/constants.txt/None:None|.

      It is set for "SELECT" statements without any matching rows as well.

   *sqlite3.Cursor.connection:connection*

      This read-only attribute provides the SQLite database |:sqlite3.Connection:Connection| used by the
      |:sqlite3.Cursor:Cursor| object.  A |:sqlite3.Cursor:Cursor| object created by calling |:sqlite3.Connection.cursor:con.cursor()| will have
      a |:sqlite3.Cursor.connection:connection| attribute that refers to *con*:

```rst
>>> con = sqlite3.connect(":memory:")
>>> cur = con.cursor()
>>> cur.connection == con
True
```

*|sqlite3-row-objects:⚓|* # row-objects:Row Objects

*sqlite3.Row:class sqlite3.Row*

   A |:sqlite3.Row:Row| instance serves as a highly optimized |:sqlite3.Connection.row_factory:row_factory| for |:sqlite3.Connection:Connection|
   objects. It tries to mimic a tuple in most of its features.

   It supports mapping access by column name and index, iteration, representation,
   equality testing and |:library/functions.txt/len:len()|.

   If two |:sqlite3.Row:Row| objects have exactly the same columns and their members are equal,
   they compare equal.

   *sqlite3.Row.keys:keys()*

      This method returns a list of column names. Immediately after a query, it is the
      first member of each tuple in |:sqlite3.Cursor.description:Cursor.description|.

   Changed in version 3.5: Added support of slicing.

Let’s assume we initialize a table as in the example given above:

```rst
conn = sqlite3.connect(":memory:")
c = conn.cursor()
c.execute('''create table stocks
(date text, trans text, symbol text,
 qty real, price real)''')
c.execute("""insert into stocks
          values ('2006-01-05','BUY','RHAT',100,35.14)""")
conn.commit()
c.close()
```

Now we plug |:sqlite3.Row:Row| in:

```rst
>>> conn.row_factory = sqlite3.Row
>>> c = conn.cursor()
>>> c.execute('select * from stocks')
<sqlite3.Cursor object at 0x7f4e7dd8fa80>
>>> r = c.fetchone()
>>> type(r)
<class 'sqlite3.Row'>
>>> tuple(r)
('2006-01-05', 'BUY', 'RHAT', 100.0, 35.14)
>>> len(r)
5
>>> r[2]
'RHAT'
>>> r.keys()
['date', 'trans', 'symbol', 'qty', 'price']
>>> r['qty']
100.0
>>> for member in r:
...     print(member)
...
2006-01-05
BUY
RHAT
100.0
35.14
```

*|sqlite3-exceptions:⚓|* # exceptions:Exceptions

*sqlite3.Warning:exception sqlite3.Warning*

   A subclass of |:library/exceptions.txt/Exception:Exception|.

*sqlite3.Error:exception sqlite3.Error*

   The base class of the other exceptions in this module.  It is a subclass of
   |:library/exceptions.txt/Exception:Exception|.

*sqlite3.DatabaseError:exception sqlite3.DatabaseError*

   Exception raised for errors that are related to the database.

*sqlite3.IntegrityError:exception sqlite3.IntegrityError*

   Exception raised when the relational integrity of the database is affected, e.g.
   a foreign key check fails.  It is a subclass of |:sqlite3.DatabaseError:DatabaseError|.

*sqlite3.ProgrammingError:exception sqlite3.ProgrammingError*

   Exception raised for programming errors, e.g. table not found or already exists,
   syntax error in the SQL statement, wrong number of parameters specified, etc.
   It is a subclass of |:sqlite3.DatabaseError:DatabaseError|.

*sqlite3.OperationalError:exception sqlite3.OperationalError*

   Exception raised for errors that are related to the database’s operation and not
   necessarily under the control of the programmer, e.g. an unexpected disconnect
   occurs, the data source name is not found, a transaction could not be processed,
   etc.  It is a subclass of |:sqlite3.DatabaseError:DatabaseError|.

*sqlite3.NotSupportedError:exception sqlite3.NotSupportedError*

   Exception raised in case a method or database API was used which is not
   supported by the database, e.g. calling the |:sqlite3.Connection.rollback:rollback()| method on a connection
   that does not support transaction or has transactions turned off.  It is a
   subclass of |:sqlite3.DatabaseError:DatabaseError|.

*|sqlite3-types:⚓|* # sqlite-and-python-types:SQLite and Python types##
introduction:Introduction

SQLite natively supports the following types: "NULL", "INTEGER", "REAL", "TEXT",
"BLOB".

The following Python types can thus be sent to SQLite without any problem:

+---------------------------------+---------------+
| Python type                     | SQLite type   |
|=================================|===============|
| |:library/constants.txt/None:N  | "NULL"        |
| one|                            |               |
+---------------------------------+---------------+
| |:library/functions.txt/int:in  | "INTEGER"     |
| t|                              |               |
+---------------------------------+---------------+
| |:library/functions.txt/float:  | "REAL"        |
| float|                          |               |
+---------------------------------+---------------+
| |:library/stdtypes.txt/str:str| | "TEXT"        |
+---------------------------------+---------------+
| |:library/stdtypes.txt/bytes:b  | "BLOB"        |
| ytes|                           |               |
+---------------------------------+---------------+

This is how SQLite types are converted to Python types by default:

+---------------+------------------------------------------------+
| SQLite type   | Python type                                    |
|===============|================================================|
| "NULL"        | |:library/constants.txt/None:None|             |
+---------------+------------------------------------------------+
| "INTEGER"     | |:library/functions.txt/int:int|               |
+---------------+------------------------------------------------+
| "REAL"        | |:library/functions.txt/float:float|           |
+---------------+------------------------------------------------+
| "TEXT"        | depends on |:sqlite3.Connection.text_factory:  |
|               | text_factory|, |:library/stdtypes.txt/str:str| |
|               | by default                                     |
+---------------+------------------------------------------------+
| "BLOB"        | |:library/stdtypes.txt/bytes:bytes|            |
+---------------+------------------------------------------------+

The type system of the |:module-sqlite3:sqlite3| module is extensible in two ways: you can store
additional Python types in a SQLite database via object adaptation, and you can
let the |:module-sqlite3:sqlite3| module convert SQLite types to different Python types via
converters.

## using-adapters-to-store-additional-python-types-in-sqlite-databases:Using
adapters to store additional Python types in SQLite databases

As described before, SQLite supports only a limited set of types natively. To
use other Python types with SQLite, you must *adapt* them to one of the sqlite3
module’s supported types for SQLite: one of NoneType, int, float, str, bytes.

There are two ways to enable the |:module-sqlite3:sqlite3| module to adapt a custom Python type
to one of the supported ones.

### letting-your-object-adapt-itself:Letting your object adapt itself

This is a good approach if you write the class yourself. Let’s suppose you have
a class like this:

```rst
class Point:
    def __init__(self, x, y):
        self.x, self.y = x, y
```

Now you want to store the point in a single SQLite column.  First you’ll have to
choose one of the supported types first to be used for representing the point.
Let’s just use str and separate the coordinates using a semicolon. Then you need
to give your class a method "__conform__(self, protocol)" which must return the
converted value. The parameter *protocol* will be "PrepareProtocol".

```rst
import sqlite3

class Point:
    def __init__(self, x, y):
        self.x, self.y = x, y

    def __conform__(self, protocol):
        if protocol is sqlite3.PrepareProtocol:
            return "%f;%f" % (self.x, self.y)

con = sqlite3.connect(":memory:")
cur = con.cursor()

p = Point(4.0, -3.2)
cur.execute("select ?", (p,))
print(cur.fetchone()[0])

con.close()

```

### registering-an-adapter-callable:Registering an adapter callable

The other possibility is to create a function that converts the type to the
string representation and register the function with |:sqlite3.register_adapter:register_adapter()|.

```rst
import sqlite3

class Point:
    def __init__(self, x, y):
        self.x, self.y = x, y

def adapt_point(point):
    return "%f;%f" % (point.x, point.y)

sqlite3.register_adapter(Point, adapt_point)

con = sqlite3.connect(":memory:")
cur = con.cursor()

p = Point(4.0, -3.2)
cur.execute("select ?", (p,))
print(cur.fetchone()[0])

con.close()

```

The |:module-sqlite3:sqlite3| module has two default adapters for Python’s built-in
|:library/datetime.txt/datetime.date:datetime.date| and |:library/datetime.txt/datetime.datetime:datetime.datetime| types.  Now let’s suppose we want to
store |:library/datetime.txt/datetime.datetime:datetime.datetime| objects not in ISO representation, but as a Unix
timestamp.

```rst
import sqlite3
import datetime
import time

def adapt_datetime(ts):
    return time.mktime(ts.timetuple())

sqlite3.register_adapter(datetime.datetime, adapt_datetime)

con = sqlite3.connect(":memory:")
cur = con.cursor()

now = datetime.datetime.now()
cur.execute("select ?", (now,))
print(cur.fetchone()[0])

con.close()

```

## converting-sqlite-values-to-custom-python-types:Converting SQLite values to
custom Python types

Writing an adapter lets you send custom Python types to SQLite. But to make it
really useful we need to make the Python to SQLite to Python roundtrip work.

Enter converters.

Let’s go back to the "Point" class. We stored the x and y coordinates separated
via semicolons as strings in SQLite.

First, we’ll define a converter function that accepts the string as a parameter
and constructs a "Point" object from it.

Note:

  Converter functions *always* get called with a |:library/stdtypes.txt/bytes:bytes| object, no matter under
  which data type you sent the value to SQLite.

```rst
def convert_point(s):
    x, y = map(float, s.split(b";"))
    return Point(x, y)
```

Now you need to make the |:module-sqlite3:sqlite3| module know that what you select from the
database is actually a point. There are two ways of doing this:

* Implicitly via the declared type

* Explicitly via the column name

Both ways are described in section |:sqlite3-module-contents:Module functions and constants|, in the
entries for the constants |:sqlite3.PARSE_DECLTYPES:PARSE_DECLTYPES| and |:sqlite3.PARSE_COLNAMES:PARSE_COLNAMES|.

The following example illustrates both approaches.

```rst
import sqlite3

class Point:
    def __init__(self, x, y):
        self.x, self.y = x, y

    def __repr__(self):
        return "(%f;%f)" % (self.x, self.y)

def adapt_point(point):
    return ("%f;%f" % (point.x, point.y)).encode('ascii')

def convert_point(s):
    x, y = list(map(float, s.split(b";")))
    return Point(x, y)

# Register the adapter
sqlite3.register_adapter(Point, adapt_point)

# Register the converter
sqlite3.register_converter("point", convert_point)

p = Point(4.0, -3.2)

#########################
# 1) Using declared types
con = sqlite3.connect(":memory:", detect_types=sqlite3.PARSE_DECLTYPES)
cur = con.cursor()
cur.execute("create table test(p point)")

cur.execute("insert into test(p) values (?)", (p,))
cur.execute("select p from test")
print("with declared types:", cur.fetchone()[0])
cur.close()
con.close()

#######################
# 1) Using column names
con = sqlite3.connect(":memory:", detect_types=sqlite3.PARSE_COLNAMES)
cur = con.cursor()
cur.execute("create table test(p)")

cur.execute("insert into test(p) values (?)", (p,))
cur.execute('select p as "p [point]" from test')
print("with column names:", cur.fetchone()[0])
cur.close()
con.close()

```

## default-adapters-and-converters:Default adapters and converters

There are default adapters for the date and datetime types in the datetime
module. They will be sent as ISO dates/ISO timestamps to SQLite.

The default converters are registered under the name “date” for |:library/datetime.txt/datetime.date:datetime.date|
and under the name “timestamp” for |:library/datetime.txt/datetime.datetime:datetime.datetime|.

This way, you can use date/timestamps from Python without any additional
fiddling in most cases. The format of the adapters is also compatible with the
experimental SQLite date/time functions.

The following example demonstrates this.

```rst
import sqlite3
import datetime

con = sqlite3.connect(":memory:", detect_types=sqlite3.PARSE_DECLTYPES|sqlite3.PARSE_COLNAMES)
cur = con.cursor()
cur.execute("create table test(d date, ts timestamp)")

today = datetime.date.today()
now = datetime.datetime.now()

cur.execute("insert into test(d, ts) values (?, ?)", (today, now))
cur.execute("select d, ts from test")
row = cur.fetchone()
print(today, "=>", row[0], type(row[0]))
print(now, "=>", row[1], type(row[1]))

cur.execute('select current_date as "d [date]", current_timestamp as "ts [timestamp]"')
row = cur.fetchone()
print("current_date", row[0], type(row[0]))
print("current_timestamp", row[1], type(row[1]))

con.close()

```

If a timestamp stored in SQLite has a fractional part longer than 6 numbers, its
value will be truncated to microsecond precision by the timestamp converter.

*|sqlite3-controlling-transactions:⚓|* # controlling-transactions:Controlling
Transactions

The underlying "sqlite3" library operates in "autocommit" mode by default, but
the Python |:module-sqlite3:sqlite3| module by default does not.

"autocommit" mode means that statements that modify the database take effect
immediately.  A "BEGIN" or "SAVEPOINT" statement disables "autocommit" mode, and
a "COMMIT", a "ROLLBACK", or a "RELEASE" that ends the outermost transaction,
turns "autocommit" mode back on.

The Python |:module-sqlite3:sqlite3| module by default issues a "BEGIN" statement implicitly
before a Data Modification Language (DML) statement (i.e. "INSERT"/"UPDATE"/"
DELETE"/"REPLACE").

You can control which kind of "BEGIN" statements |:module-sqlite3:sqlite3| implicitly executes
via the *isolation_level* parameter to the |:sqlite3.connect:connect()| call, or via the "
isolation_level" property of connections. If you specify no *isolation_level*, a
plain "BEGIN" is used, which is equivalent to specifying "DEFERRED".  Other
possible values are "IMMEDIATE" and "EXCLUSIVE".

You can disable the |:module-sqlite3:sqlite3| module’s implicit transaction management by
setting "isolation_level" to "None".  This will leave the underlying "sqlite3"
library operating in "autocommit" mode.  You can then completely control the
transaction state by explicitly issuing "BEGIN", "ROLLBACK", "SAVEPOINT", and "
RELEASE" statements in your code.

Changed in version 3.6: |:module-sqlite3:sqlite3| used to implicitly commit an open transaction
before DDL statements.  This is no longer the case.

# using-sqlite3-efficiently:Using |:module-sqlite3:sqlite3| efficiently## using-shortcut-
methods:Using shortcut methods

Using the nonstandard "execute()", "executemany()" and "executescript()" methods
of the |:sqlite3.Connection:Connection| object, your code can be written more concisely because you
don’t have to create the (often superfluous) |:sqlite3.Cursor:Cursor| objects explicitly.
Instead, the |:sqlite3.Cursor:Cursor| objects are created implicitly and these shortcut methods
return the cursor objects. This way, you can execute a "SELECT" statement and
iterate over it directly using only a single call on the |:sqlite3.Connection:Connection| object.

```rst
import sqlite3

persons = [
    ("Hugo", "Boss"),
    ("Calvin", "Klein")
    ]

con = sqlite3.connect(":memory:")

# Create the table
con.execute("create table person(firstname, lastname)")

# Fill the table
con.executemany("insert into person(firstname, lastname) values (?, ?)", persons)

# Print the table contents
for row in con.execute("select firstname, lastname from person"):
    print(row)

print("I just deleted", con.execute("delete from person").rowcount, "rows")

# close is not a shortcut method and it's not called automatically,
# so the connection object should be closed manually
con.close()

```

## accessing-columns-by-name-instead-of-by-index:Accessing columns by name
instead of by index

One useful feature of the |:module-sqlite3:sqlite3| module is the built-in |:sqlite3.Row:sqlite3.Row| class
designed to be used as a row factory.

Rows wrapped with this class can be accessed both by index (like tuples) and
case-insensitively by name:

```rst
import sqlite3

con = sqlite3.connect(":memory:")
con.row_factory = sqlite3.Row

cur = con.cursor()
cur.execute("select 'John' as name, 42 as age")
for row in cur:
    assert row[0] == row["name"]
    assert row["name"] == row["nAmE"]
    assert row[1] == row["age"]
    assert row[1] == row["AgE"]

con.close()

```

## using-the-connection-as-a-context-manager:Using the connection as a context
manager

Connection objects can be used as context managers that automatically commit or
rollback transactions.  In the event of an exception, the transaction is rolled
back; otherwise, the transaction is committed:

```rst
import sqlite3

con = sqlite3.connect(":memory:")
con.execute("create table person (id integer primary key, firstname varchar unique)")

# Successful, con.commit() is called automatically afterwards
with con:
    con.execute("insert into person(firstname) values (?)", ("Joe",))

# con.rollback() is called after the with block finishes with an exception, the
# exception is still raised and must be caught
try:
    with con:
        con.execute("insert into person(firstname) values (?)", ("Joe",))
except sqlite3.IntegrityError:
    print("couldn't add Joe twice")

# Connection object used as context manager only commits or rollbacks transactions,
# so the connection object should be closed manually
con.close()

```

-[ Footnotes ]-

[1] The sqlite3 module is not built with loadable extension support by default,
    because some platforms (notably Mac OS X) have SQLite libraries which are
    compiled without this feature. To get loadable extension support, you must pass
    –enable-loadable-sqlite-extensions to configure.



