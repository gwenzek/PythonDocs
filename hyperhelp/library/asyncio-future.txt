%hyperhelp title="Futures" date="2021-07-11"
*|futures:⚓|*

*Source code:* |:github.com/python/cpython/tree/3.8/Lib/asyncio/futures.py:Lib/asyncio/futures.py|, |:github.com/python/cpython/tree/3.8/Lib/asyncio/base_futures.py:Lib/asyncio/base_futures.py|

======================================================================

*Future* objects are used to bridge *low-level callback-based code* with high-
level async/await code.

# future-functions:Future Functions

*asyncio.isfuture:asyncio.isfuture(obj)*

   Return "True" if *obj* is either of:

   * an instance of |:asyncio.Future:asyncio.Future|,

   * an instance of |:library/asyncio-task.txt/asyncio.Task:asyncio.Task|,

   * a Future-like object with a "_asyncio_future_blocking" attribute.

   New in version 3.5.

*asyncio.ensure_future:asyncio.ensure_future(obj, *, loop=None)*

   Return:

   * *obj* argument as is, if *obj* is a |:asyncio.Future:Future|, a |:library/asyncio-task.txt/asyncio.Task:Task|, or a Future-like object
     (|:asyncio.isfuture:isfuture()| is used for the test.)

   * a |:library/asyncio-task.txt/asyncio.Task:Task| object wrapping *obj*, if *obj* is a coroutine (|:library/asyncio-task.txt/asyncio.iscoroutine:iscoroutine()| is used
     for the test); in this case the coroutine will be scheduled by "ensure_future()"
     .

   * a |:library/asyncio-task.txt/asyncio.Task:Task| object that would await on *obj*, if *obj* is an awaitable (
     |:library/inspect.txt/inspect.isawaitable:inspect.isawaitable()| is used for the test.)

   If *obj* is neither of the above a |:library/exceptions.txt/TypeError:TypeError| is raised.

   Important:

     See also the |:library/asyncio-task.txt/asyncio.create_task:create_task()| function which is the preferred way for creating
     new Tasks.

   Changed in version 3.5.1: The function accepts any |:glossary.txt/term-awaitable:awaitable| object.

*asyncio.wrap_future:asyncio.wrap_future(future, *, loop=None)*

   Wrap a |:library/concurrent.futures.txt/concurrent.futures.Future:concurrent.futures.Future| object in a |:asyncio.Future:asyncio.Future| object.

# future-object:Future Object

*asyncio.Future:class asyncio.Future(*, loop=None)*

   A Future represents an eventual result of an asynchronous operation.  Not
   thread-safe.

   Future is an |:glossary.txt/term-awaitable:awaitable| object.  Coroutines can await on Future objects until
   they either have a result or an exception set, or until they are cancelled.

   Typically Futures are used to enable low-level callback-based code (e.g. in
   protocols implemented using asyncio |:library/asyncio-protocol.txt/asyncio-transports-protocols:transports|) to interoperate with high-
   level async/await code.

   The rule of thumb is to never expose Future objects in user-facing APIs, and the
   recommended way to create a Future object is to call |:library/asyncio-eventloop.txt/asyncio.loop.create_future:loop.create_future()|.
   This way alternative event loop implementations can inject their own optimized
   implementations of a Future object.

   Changed in version 3.7: Added support for the |:library/contextvars.txt/module-contextvars:contextvars| module.

   *asyncio.Future.result:result()*

      Return the result of the Future.

      If the Future is *done* and has a result set by the |:asyncio.Future.set_result:set_result()| method, the
      result value is returned.

      If the Future is *done* and has an exception set by the |:asyncio.Future.set_exception:set_exception()|
      method, this method raises the exception.

      If the Future has been *cancelled*, this method raises a |:library/asyncio-exceptions.txt/asyncio.CancelledError:CancelledError|
      exception.

      If the Future’s result isn’t yet available, this method raises a
      |:library/asyncio-exceptions.txt/asyncio.InvalidStateError:InvalidStateError| exception.

   *asyncio.Future.set_result:set_result(result)*

      Mark the Future as *done* and set its result.

      Raises a |:library/asyncio-exceptions.txt/asyncio.InvalidStateError:InvalidStateError| error if the Future is already *done*.

   *asyncio.Future.set_exception:set_exception(exception)*

      Mark the Future as *done* and set an exception.

      Raises a |:library/asyncio-exceptions.txt/asyncio.InvalidStateError:InvalidStateError| error if the Future is already *done*.

   *asyncio.Future.done:done()*

      Return "True" if the Future is *done*.

      A Future is *done* if it was *cancelled* or if it has a result or an exception
      set with |:asyncio.Future.set_result:set_result()| or |:asyncio.Future.set_exception:set_exception()| calls.

   *asyncio.Future.cancelled:cancelled()*

      Return "True" if the Future was *cancelled*.

      The method is usually used to check if a Future is not *cancelled* before
      setting a result or an exception for it:

```rst
if not fut.cancelled():
    fut.set_result(42)
```

   *asyncio.Future.add_done_callback:add_done_callback(callback, *, context=None)*

      Add a callback to be run when the Future is *done*.

      The *callback* is called with the Future object as its only argument.

      If the Future is already *done* when this method is called, the callback is
      scheduled with |:library/asyncio-eventloop.txt/asyncio.loop.call_soon:loop.call_soon()|.

      An optional keyword-only *context* argument allows specifying a custom
      |:library/contextvars.txt/contextvars.Context:contextvars.Context| for the *callback* to run in. The current context is used
      when no *context* is provided.

      |:library/functools.txt/functools.partial:functools.partial()| can be used to pass parameters to the callback, e.g.:

```rst
# Call 'print("Future:", fut)' when "fut" is done.
fut.add_done_callback(
    functools.partial(print, "Future:"))
```

      Changed in version 3.7: The *context* keyword-only parameter was added. See
      *|index-0:⚓|* |:www.python.org/dev/peps/pep-0567:PEP 567| for more details.

   *asyncio.Future.remove_done_callback:remove_done_callback(callback)*

      Remove *callback* from the callbacks list.

      Returns the number of callbacks removed, which is typically 1, unless a callback
      was added more than once.

   *asyncio.Future.cancel:cancel()*

      Cancel the Future and schedule callbacks.

      If the Future is already *done* or *cancelled*, return "False". Otherwise,
      change the Future’s state to *cancelled*, schedule the callbacks, and return "
      True".

   *asyncio.Future.exception:exception()*

      Return the exception that was set on this Future.

      The exception (or "None" if no exception was set) is returned only if the Future
      is *done*.

      If the Future has been *cancelled*, this method raises a |:library/asyncio-exceptions.txt/asyncio.CancelledError:CancelledError|
      exception.

      If the Future isn’t *done* yet, this method raises an |:library/asyncio-exceptions.txt/asyncio.InvalidStateError:InvalidStateError|
      exception.

   *asyncio.Future.get_loop:get_loop()*

      Return the event loop the Future object is bound to.

      New in version 3.7.

*|asyncio-example-future:⚓|*

This example creates a Future object, creates and schedules an asynchronous Task
to set result for the Future, and waits until the Future has a result:

```rst
async def set_after(fut, delay, value):
    # Sleep for *delay* seconds.
    await asyncio.sleep(delay)

    # Set *value* as a result of *fut* Future.
    fut.set_result(value)

async def main():
    # Get the current event loop.
    loop = asyncio.get_running_loop()

    # Create a new Future object.
    fut = loop.create_future()

    # Run "set_after()" coroutine in a parallel Task.
    # We are using the low-level "loop.create_task()" API here because
    # we already have a reference to the event loop at hand.
    # Otherwise we could have just used "asyncio.create_task()".
    loop.create_task(
        set_after(fut, 1, '... world'))

    print('hello ...')

    # Wait until *fut* has a result (1 second) and print it.
    print(await fut)

asyncio.run(main())
```

Important:

  The Future object was designed to mimic |:library/concurrent.futures.txt/concurrent.futures.Future:concurrent.futures.Future|.  Key
  differences include:

  * unlike asyncio Futures, |:library/concurrent.futures.txt/concurrent.futures.Future:concurrent.futures.Future| instances cannot be awaited.

  * |:asyncio.Future.result:asyncio.Future.result()| and |:asyncio.Future.exception:asyncio.Future.exception()| do not accept the *
    timeout* argument.

  * |:asyncio.Future.result:asyncio.Future.result()| and |:asyncio.Future.exception:asyncio.Future.exception()| raise an
    |:library/asyncio-exceptions.txt/asyncio.InvalidStateError:InvalidStateError| exception when the Future is not *done*.

  * Callbacks registered with |:asyncio.Future.add_done_callback:asyncio.Future.add_done_callback()| are not called
    immediately.  They are scheduled with |:library/asyncio-eventloop.txt/asyncio.loop.call_soon:loop.call_soon()| instead.

  * asyncio Future is not compatible with the |:library/concurrent.futures.txt/concurrent.futures.wait:concurrent.futures.wait()| and
    |:library/concurrent.futures.txt/concurrent.futures.as_completed:concurrent.futures.as_completed()| functions.



