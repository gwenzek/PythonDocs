%hyperhelp title="base64" date="2021-07-11"
*|module-base64:⚓|*

*Source code:* |:github.com/python/cpython/tree/3.8/Lib/base64.py:Lib/base64.py|

*|index-0:⚓|*

======================================================================

This module provides functions for encoding binary data to printable ASCII
characters and decoding such encodings back to binary data. It provides encoding
and decoding functions for the encodings specified in *|index-1:⚓|* |:tools.ietf.org/html/rfc3548.html:RFC 3548|,
which defines the Base16, Base32, and Base64 algorithms, and for the de-facto
standard Ascii85 and Base85 encodings.

The *|index-2:⚓|* |:tools.ietf.org/html/rfc3548.html:RFC 3548| encodings are suitable for encoding binary data so
that it can safely sent by email, used as parts of URLs, or included as part of
an HTTP POST request.  The encoding algorithm is not the same as the *uuencode*
program.

There are two interfaces provided by this module.  The modern interface supports
encoding |:glossary.txt/term-bytes-like-object:bytes-like objects| to ASCII |:library/stdtypes.txt/bytes:bytes|, and decoding
|:glossary.txt/term-bytes-like-object:bytes-like objects| or strings containing ASCII to |:library/stdtypes.txt/bytes:bytes|.  Both base-64
alphabets defined in *|index-3:⚓|* |:tools.ietf.org/html/rfc3548.html:RFC 3548| (normal, and URL- and filesystem-
safe) are supported.

The legacy interface does not support decoding from strings, but it does provide
functions for encoding and decoding to and from |:glossary.txt/term-file-object:file objects|.  It only
supports the Base64 standard alphabet, and it adds newlines every 76 characters
as per *|index-4:⚓|* |:tools.ietf.org/html/rfc2045.html:RFC 2045|.  Note that if you are looking for *|index-5:⚓|*
|:tools.ietf.org/html/rfc2045.html:RFC 2045| support you probably want to be looking at the |:library/email.txt/module-email:email| package
instead.

Changed in version 3.3: ASCII-only Unicode strings are now accepted by the
decoding functions of the modern interface.

Changed in version 3.4: Any |:glossary.txt/term-bytes-like-object:bytes-like objects| are now accepted by all
encoding and decoding functions in this module.  Ascii85/Base85 support added.

The modern interface provides:

*base64.b64encode:base64.b64encode(s, altchars=None)*

   Encode the |:glossary.txt/term-bytes-like-object:bytes-like object| *s* using Base64 and return the encoded |:library/stdtypes.txt/bytes:bytes|.

   Optional *altchars* must be a |:glossary.txt/term-bytes-like-object:bytes-like object| of at least length 2
   (additional characters are ignored) which specifies an alternative alphabet for
   the "+" and "/" characters.  This allows an application to e.g. generate URL or
   filesystem safe Base64 strings.  The default is "None", for which the standard
   Base64 alphabet is used.

*base64.b64decode:base64.b64decode(s, altchars=None, validate=False)*

   Decode the Base64 encoded |:glossary.txt/term-bytes-like-object:bytes-like object| or ASCII string *s* and return the
   decoded |:library/stdtypes.txt/bytes:bytes|.

   Optional *altchars* must be a |:glossary.txt/term-bytes-like-object:bytes-like object| or ASCII string of at least
   length 2 (additional characters are ignored) which specifies the alternative
   alphabet used instead of the "+" and "/" characters.

   A |:library/binascii.txt/binascii.Error:binascii.Error| exception is raised if *s* is incorrectly padded.

   If *validate* is "False" (the default), characters that are neither in the
   normal base-64 alphabet nor the alternative alphabet are discarded prior to the
   padding check.  If *validate* is "True", these non-alphabet characters in the
   input result in a |:library/binascii.txt/binascii.Error:binascii.Error|.

*base64.standard_b64encode:base64.standard_b64encode(s)*

   Encode |:glossary.txt/term-bytes-like-object:bytes-like object| *s* using the standard Base64 alphabet and return the
   encoded |:library/stdtypes.txt/bytes:bytes|.

*base64.standard_b64decode:base64.standard_b64decode(s)*

   Decode |:glossary.txt/term-bytes-like-object:bytes-like object| or ASCII string *s* using the standard Base64
   alphabet and return the decoded |:library/stdtypes.txt/bytes:bytes|.

*base64.urlsafe_b64encode:base64.urlsafe_b64encode(s)*

   Encode |:glossary.txt/term-bytes-like-object:bytes-like object| *s* using the URL- and filesystem-safe alphabet,
   which substitutes "-" instead of "+" and "_" instead of "/" in the standard
   Base64 alphabet, and return the encoded |:library/stdtypes.txt/bytes:bytes|.  The result can still contain "
   =".

*base64.urlsafe_b64decode:base64.urlsafe_b64decode(s)*

   Decode |:glossary.txt/term-bytes-like-object:bytes-like object| or ASCII string *s* using the URL- and filesystem-
   safe alphabet, which substitutes "-" instead of "+" and "_" instead of "/" in
   the standard Base64 alphabet, and return the decoded |:library/stdtypes.txt/bytes:bytes|.

*base64.b32encode:base64.b32encode(s)*

   Encode the |:glossary.txt/term-bytes-like-object:bytes-like object| *s* using Base32 and return the encoded |:library/stdtypes.txt/bytes:bytes|.

*base64.b32decode:base64.b32decode(s, casefold=False, map01=None)*

   Decode the Base32 encoded |:glossary.txt/term-bytes-like-object:bytes-like object| or ASCII string *s* and return the
   decoded |:library/stdtypes.txt/bytes:bytes|.

   Optional *casefold* is a flag specifying whether a lowercase alphabet is
   acceptable as input.  For security purposes, the default is "False".

   *|index-6:⚓|* |:tools.ietf.org/html/rfc3548.html:RFC 3548| allows for optional mapping of the digit 0 (zero) to
   the letter O (oh), and for optional mapping of the digit 1 (one) to either the
   letter I (eye) or letter L (el).  The optional argument *map01* when not "None",
   specifies which letter the digit 1 should be mapped to (when *map01* is not "
   None", the digit 0 is always mapped to the letter O).  For security purposes the
   default is "None", so that 0 and 1 are not allowed in the input.

   A |:library/binascii.txt/binascii.Error:binascii.Error| is raised if *s* is incorrectly padded or if there are non-
   alphabet characters present in the input.

*base64.b16encode:base64.b16encode(s)*

   Encode the |:glossary.txt/term-bytes-like-object:bytes-like object| *s* using Base16 and return the encoded |:library/stdtypes.txt/bytes:bytes|.

*base64.b16decode:base64.b16decode(s, casefold=False)*

   Decode the Base16 encoded |:glossary.txt/term-bytes-like-object:bytes-like object| or ASCII string *s* and return the
   decoded |:library/stdtypes.txt/bytes:bytes|.

   Optional *casefold* is a flag specifying whether a lowercase alphabet is
   acceptable as input.  For security purposes, the default is "False".

   A |:library/binascii.txt/binascii.Error:binascii.Error| is raised if *s* is incorrectly padded or if there are non-
   alphabet characters present in the input.

*base64.a85encode:base64.a85encode(b, *, foldspaces=False, wrapcol=0, pad=False, adobe=False)*

   Encode the |:glossary.txt/term-bytes-like-object:bytes-like object| *b* using Ascii85 and return the encoded |:library/stdtypes.txt/bytes:bytes|.

   *foldspaces* is an optional flag that uses the special short sequence ‘y’
   instead of 4 consecutive spaces (ASCII 0x20) as supported by ‘btoa’. This
   feature is not supported by the “standard” Ascii85 encoding.

   *wrapcol* controls whether the output should have newline ("b'\n'") characters
   added to it. If this is non-zero, each output line will be at most this many
   characters long.

   *pad* controls whether the input is padded to a multiple of 4 before encoding.
   Note that the "btoa" implementation always pads.

   *adobe* controls whether the encoded byte sequence is framed with "<~" and "~>",
   which is used by the Adobe implementation.

   New in version 3.4.

*base64.a85decode:base64.a85decode(b, *, foldspaces=False, adobe=False, ignorechars=b' \\t\\n\\r\\v')*

   Decode the Ascii85 encoded |:glossary.txt/term-bytes-like-object:bytes-like object| or ASCII string *b* and return
   the decoded |:library/stdtypes.txt/bytes:bytes|.

   *foldspaces* is a flag that specifies whether the ‘y’ short sequence should be
   accepted as shorthand for 4 consecutive spaces (ASCII 0x20). This feature is not
   supported by the “standard” Ascii85 encoding.

   *adobe* controls whether the input sequence is in Adobe Ascii85 format (i.e. is
   framed with <~ and ~>).

   *ignorechars* should be a |:glossary.txt/term-bytes-like-object:bytes-like object| or ASCII string containing
   characters to ignore from the input. This should only contain whitespace
   characters, and by default contains all whitespace characters in ASCII.

   New in version 3.4.

*base64.b85encode:base64.b85encode(b, pad=False)*

   Encode the |:glossary.txt/term-bytes-like-object:bytes-like object| *b* using base85 (as used in e.g. git-style
   binary diffs) and return the encoded |:library/stdtypes.txt/bytes:bytes|.

   If *pad* is true, the input is padded with "b'\0'" so its length is a multiple
   of 4 bytes before encoding.

   New in version 3.4.

*base64.b85decode:base64.b85decode(b)*

   Decode the base85-encoded |:glossary.txt/term-bytes-like-object:bytes-like object| or ASCII string *b* and return the
   decoded |:library/stdtypes.txt/bytes:bytes|.  Padding is implicitly removed, if necessary.

   New in version 3.4.

The legacy interface:

*base64.decode:base64.decode(input, output)*

   Decode the contents of the binary *input* file and write the resulting binary
   data to the *output* file. *input* and *output* must be |:glossary.txt/term-file-object:file objects|. *input*
   will be read until "input.readline()" returns an empty bytes object.

*base64.decodebytes:base64.decodebytes(s)*

   Decode the |:glossary.txt/term-bytes-like-object:bytes-like object| *s*, which must contain one or more lines of
   base64 encoded data, and return the decoded |:library/stdtypes.txt/bytes:bytes|.

   New in version 3.1.

*base64.decodestring:base64.decodestring(s)*

   Deprecated alias of |:base64.decodebytes:decodebytes()|.

   Deprecated since version 3.1.

*base64.encode:base64.encode(input, output)*

   Encode the contents of the binary *input* file and write the resulting base64
   encoded data to the *output* file. *input* and *output* must be |:glossary.txt/term-file-object:file
objects|.
   *input* will be read until "input.read()" returns an empty bytes object.
   |:base64.encode:encode()| inserts a newline character ("b'\n'") after every 76 bytes of the
   output, as well as ensuring that the output always ends with a newline, as per
   *|index-7:⚓|* |:tools.ietf.org/html/rfc2045.html:RFC 2045| (MIME).

*base64.encodebytes:base64.encodebytes(s)*

   Encode the |:glossary.txt/term-bytes-like-object:bytes-like object| *s*, which can contain arbitrary binary data, and
   return |:library/stdtypes.txt/bytes:bytes| containing the base64-encoded data, with newlines ("b'\n'")
   inserted after every 76 bytes of output, and ensuring that there is a trailing
   newline, as per *|index-8:⚓|* |:tools.ietf.org/html/rfc2045.html:RFC 2045| (MIME).

   New in version 3.1.

*base64.encodestring:base64.encodestring(s)*

   Deprecated alias of |:base64.encodebytes:encodebytes()|.

   Deprecated since version 3.1.

An example usage of the module:

```python
>>> import base64
>>> encoded = base64.b64encode(b'data to be encoded')
>>> encoded
b'ZGF0YSB0byBiZSBlbmNvZGVk'
>>> data = base64.b64decode(encoded)
>>> data
b'data to be encoded'
```

See also:

  Module |:library/binascii.txt/module-binascii:binascii|
     Support module containing ASCII-to-binary and binary-to-ASCII conversions.

  *|index-9:⚓|*
  |:tools.ietf.org/html/rfc1521.html:RFC 1521| - MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies
     Section 5.2, “Base64 Content-Transfer-Encoding,” provides the definition of the
     base64 encoding.



