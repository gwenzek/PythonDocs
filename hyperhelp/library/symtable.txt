%hyperhelp title="symtable" date="2021-07-11"
*|module-symtable:⚓|*

*Source code:* |:github.com/python/cpython/tree/3.8/Lib/symtable.py:Lib/symtable.py|

======================================================================

Symbol tables are generated by the compiler from AST just before bytecode is
generated.  The symbol table is responsible for calculating the scope of every
identifier in the code.  |:module-symtable:symtable| provides an interface to examine these
tables.

# generating-symbol-tables:Generating Symbol Tables

*symtable.symtable:symtable.symtable(code, filename, compile_type)*

   Return the toplevel |:symtable.SymbolTable:SymbolTable| for the Python source *code*. *filename* is
   the name of the file containing the code.  *compile_type* is like the *mode*
   argument to |:library/functions.txt/compile:compile()|.

# examining-symbol-tables:Examining Symbol Tables

*symtable.SymbolTable:class symtable.SymbolTable*

   A namespace table for a block.  The constructor is not public.

   *symtable.SymbolTable.get_type:get_type()*

      Return the type of the symbol table.  Possible values are "'class'", "'module'",
      and "'function'".

   *symtable.SymbolTable.get_id:get_id()*

      Return the table’s identifier.

   *symtable.SymbolTable.get_name:get_name()*

      Return the table’s name.  This is the name of the class if the table is for a
      class, the name of the function if the table is for a function, or "'top'" if
      the table is global (|:symtable.SymbolTable.get_type:get_type()| returns "'module'").

   *symtable.SymbolTable.get_lineno:get_lineno()*

      Return the number of the first line in the block this table represents.

   *symtable.SymbolTable.is_optimized:is_optimized()*

      Return "True" if the locals in this table can be optimized.

   *symtable.SymbolTable.is_nested:is_nested()*

      Return "True" if the block is a nested class or function.

   *symtable.SymbolTable.has_children:has_children()*

      Return "True" if the block has nested namespaces within it.  These can be
      obtained with |:symtable.SymbolTable.get_children:get_children()|.

   *symtable.SymbolTable.has_exec:has_exec()*

      Return "True" if the block uses "exec".

   *symtable.SymbolTable.get_identifiers:get_identifiers()*

      Return a list of names of symbols in this table.

   *symtable.SymbolTable.lookup:lookup(name)*

      Lookup *name* in the table and return a |:symtable.Symbol:Symbol| instance.

   *symtable.SymbolTable.get_symbols:get_symbols()*

      Return a list of |:symtable.Symbol:Symbol| instances for names in the table.

   *symtable.SymbolTable.get_children:get_children()*

      Return a list of the nested symbol tables.

*symtable.Function:class symtable.Function*

   A namespace for a function or method.  This class inherits |:symtable.SymbolTable:SymbolTable|.

   *symtable.Function.get_parameters:get_parameters()*

      Return a tuple containing names of parameters to this function.

   *symtable.Function.get_locals:get_locals()*

      Return a tuple containing names of locals in this function.

   *symtable.Function.get_globals:get_globals()*

      Return a tuple containing names of globals in this function.

   *symtable.Function.get_nonlocals:get_nonlocals()*

      Return a tuple containing names of nonlocals in this function.

   *symtable.Function.get_frees:get_frees()*

      Return a tuple containing names of free variables in this function.

*symtable.Class:class symtable.Class*

   A namespace of a class.  This class inherits |:symtable.SymbolTable:SymbolTable|.

   *symtable.Class.get_methods:get_methods()*

      Return a tuple containing the names of methods declared in the class.

*symtable.Symbol:class symtable.Symbol*

   An entry in a |:symtable.SymbolTable:SymbolTable| corresponding to an identifier in the source.  The
   constructor is not public.

   *symtable.Symbol.get_name:get_name()*

      Return the symbol’s name.

   *symtable.Symbol.is_referenced:is_referenced()*

      Return "True" if the symbol is used in its block.

   *symtable.Symbol.is_imported:is_imported()*

      Return "True" if the symbol is created from an import statement.

   *symtable.Symbol.is_parameter:is_parameter()*

      Return "True" if the symbol is a parameter.

   *symtable.Symbol.is_global:is_global()*

      Return "True" if the symbol is global.

   *symtable.Symbol.is_nonlocal:is_nonlocal()*

      Return "True" if the symbol is nonlocal.

   *symtable.Symbol.is_declared_global:is_declared_global()*

      Return "True" if the symbol is declared global with a global statement.

   *symtable.Symbol.is_local:is_local()*

      Return "True" if the symbol is local to its block.

   *symtable.Symbol.is_annotated:is_annotated()*

      Return "True" if the symbol is annotated.

      New in version 3.6.

   *symtable.Symbol.is_free:is_free()*

      Return "True" if the symbol is referenced in its block, but not assigned to.

   *symtable.Symbol.is_assigned:is_assigned()*

      Return "True" if the symbol is assigned to in its block.

   *symtable.Symbol.is_namespace:is_namespace()*

      Return "True" if name binding introduces new namespace.

      If the name is used as the target of a function or class statement, this will be
      true.

      For example:

```rst
>>> table = symtable.symtable("def some_func(): pass", "string", "exec")
>>> table.lookup("some_func").is_namespace()
True
```

      Note that a single name can be bound to multiple objects.  If the result is "
      True", the name may also be bound to other objects, like an int or list, that
      does not introduce a new namespace.

   *symtable.Symbol.get_namespaces:get_namespaces()*

      Return a list of namespaces bound to this name.

   *symtable.Symbol.get_namespace:get_namespace()*

      Return the namespace bound to this name.  If more than one namespace is bound,
      |:library/exceptions.txt/ValueError:ValueError| is raised.



